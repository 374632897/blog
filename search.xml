<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2015小记</title>
    <url>/2016/02/01/2015%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>算算日子，从9月份接触前端至今，已经过了有5个月了。到现在，想到自己走上程序员这条路的缘由，都觉得满是惊奇。 </p>
<p>仔细说起来，还得从大四的那段时间开始说起。原本自己是准备去当兵的，为此，还在大二的时候做了近视手术（话说从来很少向家里开口要钱的我，当初要钱做手术的时候，都觉得脸上烧的不行）。因为有了这样的念想，大四也没怎么找工作，其实也有找过，可是核电几巨头都看不上俺o╯□╰o。虽然传说中大学生当兵，只要没太大的问题，一般都能过的，不过为了以防万一，我还是随便签了一份工作。哦，对了，在3月份的时候，因为觉得没什么事情做，还去考了个公务员，虽然也进面了，但是因为和当兵体检的时间冲突，就没有报名面试。</p>
<a id="more"></a>  


<p>毕业之后，等到7月1号体检完了便回了家，然后等啊等，等到了8月3号，通知我去复检。这个时候我还抱着幻想，以为只是上面的抽查而已，应该能过的。 结果去了之后，告诉我心电图不正常，要重新检查一遍，检查完之后又让我回去等消息，这一等便等到了18号，告诉我没有通过体检。当时的心情，怎么说呢，感觉自己整个人一下子就被人给掏空了。盼了这么久，却没盼到自己想要的结果。之后我便慌了， 毕竟已经毕业有一个多月了，原本捉摸着能够成功去部队的话，这段时间我还可以用陪伴家人的理由来宽慰自己。可是现在部队也去不成了，自己也是成年人了，如果继续在家里呆着啃老的话，我是无论如何也不肯的。想起自己当初签的那份工作，便打了电话给那边的HR， 结果HR说她现在不方便，让我直接联系老总（后来才知道，原来她已经辞职走了），我又给老总打了电话，他告诉我这个事情需要公司协商一下，让我等消息。等到了19号的时候，那边通知我过去的时候给他们说一声，随后我便买了21号去北京的票。或许当时也是心里太慌了吧， 做起事情来都是火急火燎的， 巴不得马上离开家出去打拼去。 </p>
<p>到了这边之后， 因为是刚刚来，没什么事情做，然后整天就在办公室里坐着，看着一大堆的说明书，还全是英文的，头大啊→_→，每天上下班时间也是规定死的，又因为住的地方就在公司楼上，所以一天到晚大把大把的时间。一想到自己都是出来工作的人了，总不能白白虚度光阴吧。然后便开始找东西看。。。忘了是从哪儿听到的网易云课堂，总之是在上面找了一些视频来看，看了许多，最后对十八哥的div + css布局的内容比较感兴趣， 便好好的看了， 结果好像到现在都没把那段视频看完。总之知道了那是web前端的内容之后便直接去了百度贴吧（当初考公务员的时候就是从贴吧里边找资源的来着），希望在里面看看别人是怎么学的。。。结果还淘到了好东西——网易前端微专业的课程， 官方售价好像是1000多， 我是直接用百度云下下来看了。。。 还走w3school上面看了html,css,javascript的教程什么， 现在也时不时地上去看。</p>
<p>对这个行业接触了一段时间之后， 我发现我是深深的喜欢上了它，甚至有几次因为碰到了问题找不到原因，结果连饭都忘记吃了，等我问题解决完了想起吃饭的时候，饭也已经冷了。在这样一条道路上，最大的问题便是没有人带，靠自己一个人摸索，碰到了问题，也得自己百度， 或者走群里面问或者就是自己改改改，虽然麻烦了点，不过收获也是巨大的，巩固了知识点，同时那种依靠自己成功解决问题之后的快乐也是极为让人享受的。 </p>
<p>然后9月底的时候买了JAVASCRIPT高级程序设计，原本是准备国庆七天的时间把书给啃完的，结果好像那几天赶上琅琊榜热播？？反正最后7天完了之后我连一半都没啃到， 等到国庆节快结束的时候， 我这心里可是。。。担心不已啊。。</p>
<p>久了之后， 公司自然也就给安排活儿了。一般就是跑腿儿，不过这一跑跑的有点远，从密云跑到房山，也就是从北京东北方向跑到西南方向，坐车也要坐两三个小时。  其实最开始的时候， 我以为我是能够适应出差的（虽然这只是小差）， 毕竟出差多好啊，公司给报销， 自己还能到处跑，见识各个地方的风土人情，真是爽。可是当自己真正的出过几次之后，就觉得自己实在是不能接受出差了。一来以我这挑食的尿性，出一次差，连吃饭都是个问题了，一般早上随便吃一点儿，然后饿到回来之后自己弄，二来，觉得一出差就得坐车坐车坐车，大好青春就浪费在坐车上了，实在是不划算。再加上那一段时间觉得自己学的前端知识勉勉强强能看了，并且有了瓶颈，心里太浮躁， 并且也找不到学习的方向了， 再这样下去自己也只是重复做着某一件事情而已， 不会有太大的提升的。 于是我便有了辞职的打算。 </p>
<p>然后我开始投简历啊， 51， 智联，拉勾，周伯通，大街，哦，对了还有个5858这玩意儿响应速度就是快，当天投的，当天就收到了回应，只不过人家不是招你去工作的， 而是招你去培训的， 培训费都得1W+ 呢。。本来对58的印象就不是很好，结果这一来就更讨厌58了。 走智联上投了那么多，是没有一家回我的，毕竟以我这非科班的出身，又才接触行业一个多月的经历，谁会要我呢是吧。了两三天没收到通知之后，自己也就老老实实地跑去搬砖去了（确实是搬砖，铅砖，普通砖头大小，一块儿26斤，o╯□╰o。期间也收到了两次面试通知， 可是人家都只在工作日面试，而我这么一新来的，也不好意思开口跟领导说，领导，我请个小假去面个小试行不行是吧，所以最后这事儿也是不了了之了，我捉摸着还是继续巩固一下知识吧。结果这没过多久自己心里又悸动了，因为觉得自己无法忍受现在这样的重复的看不到未来的工作，并且自己那段时间也确实没学到什么东西，于是便下定决心，破釜沉舟，直接把工作辞掉然后再找工作，因为如果要是像这样继续下去，就算自己再收到面试邀请的话，也没有去面试的时间，所以还不如直接辞了赌一把呢。于是说干就干，当天便开始新一轮投简历攻势，我居然又投了58，没事儿，骚扰电话就骚扰电话吧，万一一不小心，瞎猫碰到死耗子，我真被HR给相中了呢。同时也开始找房子， 毕竟现在住的是公司的房子，而且工作之后也肯定是会换地方的。结果谁曾想，这一次的效率这么高，头一天投了简历，第二天就收到了HR的私信，而且还都是大街上的，让我给他们发自己的个人简历和作品过去，随后我就把自己仿制的公司的官网给打包发了过去。 等了大概有一天左右吧，有一家公司就打电话问我一些问题啊什么的，后来还问我什么时候能够面试，最后约了周六，而另外一家公司就不了了之了。 </p>
<p>具体的面试过程就不说了， 最后我是来到了这家公司， 也很感谢现东家不嫌弃我这个当时只有两个月的自学经历的小菜鸟。 </p>
<p>到了这边之后 ， 感觉好像一下子有人引导了（其实也没啥引导，还是自学，只是有了个方向而已，毕竟大家平时都有着自己的事情），总之觉得自己需要学的东西太多太多了，然后就被需求牵着鼻子走，需要什么就补什么。。。其实刚来那段时间都是在学Backbone。值得庆幸的是， 我来到的第一家公司，产品是web应用，做UI的也是用的sketch，因此我并没有沦为一个苦逼的切图仔，所以可以花更多的时间来学习一些必要的东西，而不是重复的切图切图切图，测量测量测量。那段时间，自己整个人都是干劲满满。觉得这样的生活才有意义。 甚至我还因此而为大学四年虚度的光阴懊悔不已，如果我能够早一日接触到前端的话，或许。。或许。。。也没那么多或许。还是老老实实地码代码吧。 </p>
<p>最近这两天自己的心里又开始浮躁了，因为自己不是科班出身的，觉得自己要比别人更努力才能超越别人，所以总是给自己太多的压力， 想要一口气吃成一个大胖子， 连JS都还没啃完呢， 就想要开始啃php,nodejs了。而只是前端这一块儿，也还有那么多需要学习的东西， 各种框架（虽说原生JS好， 可是框架这玩意儿找工作的时候能加分啊）层出不穷， 还有ES6， 打包管理工具，微信开发， 移动开发 等等等等一大堆东西，所以自己这一口下去，饭是吃到了，却差点把自己给噎死，得不偿失，什么都没学到，反而把自己给折磨得没个人样儿了 。所以这两天心里总是浮躁的紧呢。也就把这一篇自己一直想写却又不知道怎么写的东西给磨出来了。算是借此平息一下自己那悸动的内心吧。 </p>
<p>每次纳兹碰到比自己强大的对手， 被对方打的不要不要的的时候，总会飚一句，“我燃起来了”。我感觉我现在也燃起来了，只不过我面对的不是对手，而是一个又一个的挑战，是那一个又一个的晋级的阶梯，迈过它们，我的职业技能会有所提升，未来也就会更加明朗。最大的挑战还是自己，别搞到最后，自己把自己给折磨死了，那可就闹了个大笑话了。因为有了渴望拥有和想要守护的东西，所以，2016，加油吧， 希望新的一年里， 自己的能力能有质的提升。 </p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.12.23（关键词：Socket）</title>
    <url>/2019/12/23/2019.12.23%EF%BC%88%E5%85%B3%E9%94%AE%E8%AF%8D%EF%BC%9ASocket%EF%BC%89/</url>
    <content><![CDATA[<p><a name="7NnIC"></a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS9saW5rZWRpbi1pbnN0YW50LW1lc3NhZ2U=">LinkedIn 的即时消息：在一台机器上支持几十万条长连接<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<a id="more"></a> 
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNDA0NDM1MQ==">一篇搞懂TCP、HTTP、Socket、Socket连接池<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a name="NOHFl"></a></p>
<h2 id="LinkedIn-的即时消息：在一台机器上支持几十万条长连接"><a href="#LinkedIn-的即时消息：在一台机器上支持几十万条长连接" class="headerlink" title="LinkedIn 的即时消息：在一台机器上支持几十万条长连接"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS9saW5rZWRpbi1pbnN0YW50LW1lc3NhZ2U=">LinkedIn 的即时消息：在一台机器上支持几十万条长连接<i class="fa fa-external-link-alt"></i></span></h2><ul>
<li>Socket 等待限制</li>
</ul>
<p>**      net.core.somaxconn，通过该参数可以控制程序接受的处于等待中的最大的TCP连接数量（存疑）。**</p>
<ul>
<li>JVM 线程数量限制</li>
</ul>
<p>Java 是多线程的，每当有一个请求到达的时候，就会新开一个线程进行处理。<strong>一个线程的栈大小决定了可以用 来做静态内存分配的内存量</strong>。这样，<strong>理论上的最大线程数量就是一个进程的用户地址空间大小除以线程的栈大小</strong>。不过，实际上 <strong>JVM 也会把内存用于堆上的动态分配</strong>。在用一个小 Java 程序做了一些简单实验之后，我们证实了如果堆分配的内存多，那栈可以用的内存就少。这样，线程数量的限制会随着堆大小的增加而减少。结论就是，如果你想增加线程数量限制，<strong>你可以减少每个线程使用的栈大小（-Xss），也可以减少分配给堆的内存（-Xms，-Xmx）</strong>。</p>
<ul>
<li>临时端口耗尽</li>
</ul>
<p>来自客户端的请求通常是打到负载均衡服务器上的，负载均衡服务器需要和对应的下游服务节点进行通信，因此，负载均衡服务器会新开一个临时端口，之所以叫做临时端口，是因为在这个连接的生命周期内，该端口都会与之关联，一旦连接终止，就会释放该端口。而长连接一直不会断开，因此端口得不到释放，可能会出现负载均衡服务器端口耗尽的问题。</p>
<ul>
<li>文件描述符</li>
</ul>
<p>Unix系统遵循一切都是文件的理念。因此，比如Socket，一个Socket 也对应了一个文件句柄，通过ulimit -n 可以查看当前用户可使用的文件数。通过 <code>cat /proc/{pid}/limits</code> 可以查看到单个进程最多可以打开的文件数。如果要针对单个进程可打开的最大文件数进行修改的话，可以修改文件 <code>/etc/security/limits.conf</code> 。此外，还有一个系统级别的设置<code>/etc/sysctl.conf</code> - fs.file-max</p>
<ul>
<li>JVM 堆</li>
</ul>
]]></content>
      <tags>
        <tag>每天学习一丢丢~</tag>
      </tags>
  </entry>
  <entry>
    <title>git bash 设置别名</title>
    <url>/2016/08/09/Bash-for-windows-%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D/</url>
    <content><![CDATA[<p>平时在windows上做开发的时候， 总觉得其命令行不好用， 所以使用命令行的时候， 都是用的<code>git bash</code>。然后每次需要提交代码的时候， 总是会<code>git add .</code>, <code>git commit -m &#39;..&#39;</code> , <code>git push</code>, 至少都要输入这么三条命令，实在是麻烦。 那么有没有什么办法可以简化操作呢？</p>
<a id="more"></a>
<p>最开始的时候我用的<code>shell</code>， 在每个仓库的根目录下都建立一个<code>all.sh</code>， 长相大概就是这样：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">dm=<span class="string">':smirk:'</span>;</span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="variable">$1</span> ]; <span class="keyword">then</span></span><br><span class="line">  dm=<span class="variable">$1</span>;</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line">git add --all;</span><br><span class="line">git commit -m <span class="string">"<span class="variable">$dm</span>"</span>;</span><br><span class="line">git push;</span><br></pre></td></tr></table></figure>
<p>然后每次提交的时候直接运行<code>bash ./all.sh</code>就行了， 那么问题来了， 这样一来的话， 每次创建一个仓库， 就要复制一下这个文件，还是麻烦。</p>
<p><code>linux</code>下可以给<code>bash</code>设置别名， 比如通过修改<code>/etc/.bashrc</code>， 但是在<code>bash for windows</code>下应该怎么做呢？</p>
<p>其实吧。。 <code>bash for windows</code>也是有类似的文件的， 只不过不叫<code>.bashrc</code>而是<code>bash.bashrc</code>, 位置在<code>/etc/bash.bashrc</code>那里，当然， 具体的位置可能会因为git版本的不同而有所不同， windows下没有<code>etc</code> ? 没事儿， 在bash下直接cd就进去了。</p>
<p>然后就加了别名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># alias</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> ls=<span class="string">'ls --color=auto'</span>;</span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">'ls -lh'</span>;</span><br><span class="line"><span class="built_in">alias</span> all=<span class="string">'git add --all &amp;&amp; git commit -m ":smirk:" &amp;&amp; git push'</span>;</span><br><span class="line"><span class="built_in">alias</span> ..=<span class="string">'cd ..'</span>;</span><br><span class="line"><span class="built_in">alias</span> ....=<span class="string">'cd ../../'</span>;</span><br><span class="line"><span class="built_in">alias</span> ld=<span class="string">'ll | grep "^d"'</span>;</span><br><span class="line"><span class="built_in">alias</span> psw=<span class="string">'ps -a --windows'</span>;</span><br><span class="line"><span class="built_in">alias</span> vi=<span class="string">'vim'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是cygwin下针对快速切换到挂载目录设置的别名</span></span><br><span class="line"><span class="built_in">alias</span> d=<span class="string">'cd /cygdrive/d'</span>;</span><br><span class="line"><span class="built_in">alias</span> ng=<span class="string">'cd /cygdrive/d/nginx-1.6.0'</span>;</span><br><span class="line"><span class="built_in">alias</span> gi=<span class="string">'cd /cygdrive/d/JGX/GitHub'</span>;</span><br></pre></td></tr></table></figure>
<p>重启下bash , 然后就能够使用了。</p>
<p>虽然<code>git bash</code>用着也还行， 不过还是对不少的linux命令没有提供支持， 另外一个软件<code>cygwin</code>也挺不错， 支持也挺多的， 如果安装<code>cygwin</code>的话， 需要注意一点， 也就是它默认不会安装<code>vim</code>， 所以在选择软件的时候需要留意一下。另外， <code>git bash</code>好像会比<code>cygwin</code>快一点， <code>cygwin</code>在运行未运行过的程序的时候， 反应会比较慢（查找去了？）， 另外， 关于<code>git</code>, 在<code>cygwin</code>下好像也需要重新配置。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5 Canvas核心技术读书感悟</title>
    <url>/2016/07/04/HTML5-Canvas%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<p><code>HTML5 Canvas核心技术</code>读书感悟</p>
<p>看了一段时间的<code>HTML5 Canvas核心技术</code>， 简单谈谈感悟吧。 </p>
<a id="more"></a>

<h2 id="感觉还不错的"><a href="#感觉还不错的" class="headerlink" title="感觉还不错的"></a>感觉还不错的</h2><ul>
<li><strong>思想</strong></li>
</ul>
<p>自己以前从来没接触过图形学， 虽然也在视频上面学过一段时间的<code>canvas</code>, 但是看视频学习的效果是确实赶不上看书的效果的。 以前的时候， 实现一些图形效果的话， 总是会走很多弯路， 思路条理不清晰， 逻辑不通顺，因此为了实现一个目标， 往往会走很多弯路， 从而造成代码的冗余以及维护的困难， 所以归根结底这其实就是一个思路的问题， 脑袋转不过来了， 结果就是这样（其实就是太久没接触数学， 所以越来越笨了）。</p>
<ul>
<li><strong>面向</strong></li>
</ul>
<p>本来学习这个的目的， 除了系统性地学习<code>canvas</code>之外， 便是对各种各样的炫酷的效果有个了解， 知道他们的实现过程， 当然， 现在也确实达到了这样的目的， 里面的介绍还算全面还算不错， 虽然偶尔会有点小困惑， 但是并不影响理解。</p>
<h2 id="槽点"><a href="#槽点" class="headerlink" title="槽点"></a>槽点</h2><ul>
<li><strong>勘误过多</strong>  </li>
</ul>
<p>这本书的错误太多了， 不知道是不是涉及到的数学知识比较多， 总之， 这里面的内容， 有些东西存在根本上的逻辑错误， 虽然最后能够得到正确的结果， 但是毫无疑问， 这种情况下得到的结果完全是凑出来的。想不通的是， 为什么就这样的一本书居然也能够出版， 而且其作者居然是一个专业的图形开发人员。</p>
<ul>
<li><strong>没有明确受众群体， 内容安排不合理</strong>  </li>
</ul>
<p>这本书的跨度太大了， 当然 ， 如果其原本定位的受众就是具备图形开发经验的人员的话， 那我无话可说。里面的很多东西还没开始介绍， 就已经开始使用了， 这样子总归是会让人很困惑的。 相比之下，<code>JavaScript高级程序设计</code>和<code>Understanding ECMAScript 6</code>就好多了（作者都是同一个， N.C.Zakas）, 它们都有一个特点，那就是循序渐进，由浅入深， 在一个知识点没有讲到的时候， 绝对不会在前面的内容里对这个知识点进行过多的使用， 所以这两本书看起来都是比较轻松的。尤其是对于喜爱过程式阅读的人而言。而<code>HTML5 Canvas核心技术</code>这本书对于使用过程式阅读的人而言则毫无疑问是一种噩梦， 看书的时候常常会想， 这个API不是还没提到么， 怎么就开始使用了？ 当然， 对于喜爱泛式阅读的人来说， 可能会好点吧。</p>
<ul>
<li><strong>代码风格</strong></li>
</ul>
<p>作为一个有强迫症的人， 是不能忍受自己不习惯的代码风格的。 漏写空格、<code>else</code>和花括号的位置没在同一行等等， 每次看到的时候都觉得挺怪的。 当然， 这个只是个人问题了。 另外， 感觉作者终归不是写<code>JS</code>出身的， 或者说不是写程序出身的， 很多地方， 明明只需要1个循环就能解决的问题， 偏偏要用两个甚至更多的循环。</p>
]]></content>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub仓库绑定二级域名</title>
    <url>/2016/06/03/GitHub%E4%BB%93%E5%BA%93%E7%BB%91%E5%AE%9A%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<ol>
<li><p>在仓库创建<code>gh-pages</code>分支</p>
</li>
<li><p>在该分支根目录下添加<code>CNAME</code>文件，文件内容是你希望指向的域名，需要注意的是不需要加协议，如期望网址是<code>http://algorithms.noteawesome.com</code>的话， 就直接写<code>algorithms.noteawesome.com</code>.</p>
<a id="more"></a>
<p><img data-src="http://o869zxhjd.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160603130619.png" alt="创建CNAME文件"><br>在完成创建之后可以前往仓库设置查看是否设置成功<br><img data-src="http://o869zxhjd.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160603131423.png" alt="检验是否设置成功"></p>
</li>
<li><p>前往域名控制中心添加域名解析<br><img data-src="http://o869zxhjd.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160603131304.png" alt="添加解析"></p>
</li>
<li><p>慢慢等， 也可以用<code>ping &#39;your site&#39;</code>来查看是否成功设置<br><img data-src="http://o869zxhjd.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160603131646.png" alt="是否解析成功"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>Understanding ECMAScript6读书笔记</title>
    <url>/2016/08/08/Understanding-ECMAScript6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="关于const和let"><a href="#关于const和let" class="headerlink" title="关于const和let"></a>关于<code>const</code>和<code>let</code></h1><ul>
<li>没有变量声明提升， 存在TDZ，因此下列情况下会报错（使用<code>typeof</code>大多不会报错， 但是<code>const</code>和<code>let</code>是个例外）<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> name);<span class="comment">// Uncaught ReferenceError: name is not defined</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">say();</span><br></pre></td></tr></table></figure></li>
<li>不能在同一作用域内重复声明</li>
<li>在<code>for...in</code>和<code>for...of</code>循环里面， 每次的循环都会重新绑定上下文， 所以此时的变量声明应该用<code>const</code>来代替<code>let</code>，但是在<code>for</code>循环里就行不通了。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jason'</span>,</span><br><span class="line">  age: <span class="number">22</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>关于使用块级作用域的最佳实践就是默认使用<code>const</code>， 只有在你知道这个变量有可能发生变化的时候， 才使用<code>let</code></li>
</ul>
<h1 id="关于字符串和正则表达式"><a href="#关于字符串和正则表达式" class="headerlink" title="关于字符串和正则表达式"></a>关于字符串和正则表达式</h1><ul>
<li><p>涉及到<code>UTF-16</code>部分的知识， 因为用得很少， 所以就直接略过了。</p>
</li>
<li><p>正则表达式新增<code>u</code>标记， 用来表明进行<code>unicode</code>匹配?? 要检测浏览器是否支持该标记， 应该使用正则表达式的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSupportUFlag</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'.'</span>, <span class="string">'u'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串新增检测方法</p>
<ul>
<li><code>includes</code> 注意是<code>includes</code>而不是<code>include</code> . 检测字符串是否包含指定字符</li>
<li><code>startsWith</code> 注意是<code>startsWith</code>而不是<code>startWith</code>, 检测字符串是否以指定字符开始</li>
<li><code>endsWith</code>注意是<code>endsWith</code>而不是<code>endWith</code>, 检测字符串是否以指定字符结束</li>
<li>以上三种方法都接受两个参数， 第一个参数为字符串（注意：不能是正则表达式），第二个参数为开始的位置</li>
<li>当第二个参数的值大于字符串长度的时候， 可以理解为将会忽略该参数（实际上此时<code>startsWith</code>和<code>includes</code>将会从字符串开始处进行查找， 而<code>endsWith</code>会从结尾处开始查找， 所以其实也是差不多的）。</li>
</ul>
</li>
<li><p>字符串重复方法<code>repeat</code>, 参数为期待重复次数（重复为0的时候字符串为空）</p>
</li>
<li><p>正则表达式的<code>y</code>标识， 告诉引擎从指定的<code>lastIndex</code>开始进行匹配（应该是需要其每个都匹配，而不是跳跃性匹配）， 如果找不到匹配项， 将会停止匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/hello\d\s?/y</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello1 hello2 hello3'</span>;</span><br><span class="line">re.exec(str); <span class="comment">// ["hello1 "]</span></span><br><span class="line">re.lastIndex = <span class="number">1</span>; <span class="comment">// 指定从字符串索引为1的位置开始进行匹配</span></span><br><span class="line">re.exec(str);<span class="comment">// null</span></span><br></pre></td></tr></table></figure></li>
<li><p>正则表达式新增特性</p>
<ul>
<li>当使用正则表达式字面量来作为<code>new RegExp</code>的第一个参数的时候， 在<code>ES5</code>下， 第二个参数不能够为标识符， 但是在<code>ES6</code>下， 是可以的。但是要注意的是， 这样得到的正则表达式， 其标识符将完全由指定的第二个参数决定， 与原来的字面量无关。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/hello/y</span>;</span><br><span class="line"><span class="keyword">var</span> _re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re, <span class="string">'ig'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(_re); <span class="comment">// /hello/gi // 注意这里排序了的， 另外， 其原有的y标识没了</span></span><br></pre></td></tr></table></figure>
<ul>
<li>新增正则表达式的<code>flags</code>属性， 用于返回正则表达式的标识符</li>
</ul>
</li>
<li><p>模板字符串</p>
<ul>
<li><p>在模板字符串里使用未经定义的变量的话会报错</p>
</li>
<li><p>关于标签</p>
<ul>
<li>使用一个函数来定义标签</li>
<li>使用的时候直接使用函数名``模板字符串即可</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="built_in">console</span>.log(args);</span><br><span class="line">test<span class="string">`hello world`</span>; <span class="comment">// [Array[1]]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>该标签函数的第一个参数为字符串数组， 其每一项为模板字符串所用变量切割后组成的字符串， 其他参数则依次为由变量所解析出来的结果。</li>
<li>书上面说的使用模板字符串可以实现转义效果，但是自己试了并不行， 不知道为什么。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Multiline\nstring`</span>; <span class="comment">// 书上的结果是"Multiline\\nstring", 但是自己得到的结果还是"Multiline\nstring"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li><p>函数默认参数。 只有在调用函数的时候没有在指定位置传递参数的情况下才会使用默认参数， 这个判断过程可以认为是通过<code>typeof</code>来判断的。也就是说， 只有在参数值为<code>undefined</code>的时候才会使用（特别指定为<code>undefined</code>或者说没有传递该参数的时候）默认参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="literal">undefined</span>, <span class="literal">null</span>, <span class="number">0</span>); <span class="comment">// 1 null 0</span></span><br></pre></td></tr></table></figure></li>
<li><p>ES6下对函数参数的重赋值不会反映到函数的<code>arguments</code>对象上(自己试了下， 只有在严格模式下才不会)</p>
</li>
<li><p>函数的默认参数也存在TDZ， 也就是说， 在他们被初始化之前， 是不能够被访问的， 因此在函数参数里面， 一个参数只具有对其前面位置的参数的访问权限， 如果尝试访问后面的参数的时候， 就会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first = second, second</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 书上的这里写了throws error ， 但是实际上这里不应该会报错的， 因为指定了第一个参数， 那么就不会调用first = second. 所以也就不会访问第二个参数， 因此第二个参数是undefined， 所以最后的结果应该是NaN， 实际上检测出来的也是这种情况。</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="literal">undefined</span>, <span class="number">1</span>)); <span class="comment">// 要想触发报错的话， 可以手动指定第一个参数为undefined， 所以， 感觉上这种情况应该会比较少</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>rest</code>参数</p>
<ul>
<li><code>rest</code>只能有一个， 并且必须在最后</li>
<li>在对象字面量的<code>setter</code>里面是不能够使用<code>rest</code>参数的（书上是这样写的， 但是自己尝试了以后发现是可以的）， 因为<code>setter</code>函数被限制为只能够接受1个参数。 PS: 方式不对<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的方式</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="keyword">set</span> (...rest) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rest); <span class="comment">// 这里set只是其一个方法， 并没有涉及到setter</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确的报错打开方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">set</span> name (...rest) &#123; <span class="comment">// 此时才算是调用了setter</span></span><br><span class="line">    <span class="comment">// Setter function argument must not be a rest parameter</span></span><br><span class="line">    <span class="keyword">this</span>.name = rest;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>spread</code>可以用于将数组内容展开。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(...arr); <span class="comment">// 相当于是把数组两遍的方括号去掉</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数的<code>name</code>属性</p>
<ul>
<li>如果函数有name(<code>function</code>关键字后面的词)， 则其name属性为其name， 若有函数名， 则为函数名</li>
<li>匿名函数的name在没有指定name的情况下为<code>anonymous function</code></li>
<li>使用<code>bind</code>绑定了上下文的函数其name属性会被添加<code>bound</code>前缀</li>
<li>name属性只是起到一个标识的作用以便于调试， 并不能够通过name来获取到一个函数的引用。</li>
</ul>
</li>
<li><p>函数调用的两种方法</p>
<ul>
<li>在调用函数的时候如果使用了<code>new</code>操作符， 那么就会调用函数的[[construct]]方法</li>
<li>如果没有使用<code>new</code>操作符， 那么将会调用函数的[[call]]方法。</li>
<li>箭头函数不能用作构造函数， 也就是说不能够使用<code>new</code>操作符</li>
<li><code>new.target</code>: 在使用了new操作符的时候，<code>new.target</code>的将会指向这个函数， 否则将会是<code>udnefined</code>.</li>
<li>在函数体外面使用<code>new.target</code>将会抛出语法错误</li>
</ul>
</li>
<li><p>块级函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s1ayName);<span class="comment">// undefined;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> sayName); <span class="comment">// function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">s1ayName</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s1ayName); <span class="comment">// 在严格模式下， 这里是undefined, 非严格模式下这里是function</span></span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数</p>
<ul>
<li><p>没有<code>this</code>, <code>super</code>, <code>arguments</code>, <code>new.target</code>绑定。 箭头函数内的这些值都由距离该函数最近且包含该函数的非箭头函数所决定。</p>
</li>
<li><p>不能对箭头函数使用<code>new</code>操作符（箭头函数不具有<code>[[construct]]</code>方法）</p>
</li>
<li><p>没有原型对象（prototype）。</p>
</li>
<li><p>不能改变this（普通函数作为构造函数的时候其this是指向新构建的对象的）</p>
</li>
<li><p>没有arguments对象作为函数参数列表</p>
</li>
<li><p>没有重复命名参数（No duplicate named arguments）， 这个不大懂</p>
</li>
<li><p>箭头函数语法上需要注意的一些地方</p>
<ul>
<li>箭头函数里的花括号主要用于标识函数体， 当你希望返回一个对象的时候， 需要将该对象用圆括号包裹。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">get</span> = id =&gt; (&#123; name: <span class="string">'Jason'</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>对箭头函数使用自调用立即执行函数表达式（IIFE – imediately invoked function expressions）的时候， 需要使用圆括号将函数体包裹起来。</li>
</ul>
</li>
</ul>
</li>
<li><p>尾调用优化（Tail call Optimization）</p>
<ul>
<li>尾调用的函数不会访问当前调用栈中的变量， 也就是说当前的函数不是一个闭包</li>
<li>在尾调用执行后没有其他操作</li>
<li>尾调用的值会作为函数值返回（需要有return）</li>
<li>例如， 以下情况下不会有尾调用优化：<ul>
<li>函数尾调用另一个函数的时候没有返回该函数执行结果的值</li>
<li><code>return</code>语句里有除了函数调用之外的其他操作</li>
<li>另外， 在把一个函数的执行结果保存为变量，然后再返回这个变量的话， 也不会有尾调用优化（尾调用函数的结果需要立即返回）</li>
<li>闭包</li>
</ul>
</li>
</ul>
</li>
<li><p>怎样管理尾调用优化</p>
<ul>
<li>尾调用优化常用于函数递归</li>
</ul>
</li>
</ul>
<h1 id="对象函数展开式"><a href="#对象函数展开式" class="headerlink" title="对象函数展开式"></a>对象函数展开式</h1><ul>
<li>对象简写 — 可以使用<code>super</code>, 非简写形式不行。 此外， 简写形式下不能使用bind</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  sayName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Jason"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>改变对象原型</p>
<ul>
<li>通常情况下， 对象的原型会在对象创建的时候通过构造器或者Object.create()方法来指定</li>
<li><code>Object.setPrototypeOf(object, prototype)</code> 方法允许你通过给定的对象来改变原型(将prototype设为object的原型对象）</li>
<li>对象的原型对象保存在内部属性[[prototype]]中</li>
</ul>
</li>
<li><p>使用超类（super）引用进行更简单的原型对象访问</p>
<ul>
<li>最简单的使用便是通过super来访问当前对象的原型对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> base = &#123;</span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'base'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="keyword">super</span>.say();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(c, base);</span><br><span class="line">c.say();</span><br><span class="line"><span class="comment">// 'base'</span></span><br><span class="line"><span class="comment">// 'c'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// var friend = &#123;</span></span><br><span class="line"><span class="comment">//  say () &#123;</span></span><br><span class="line"><span class="comment">//    return super.say(); // 类似于Object.getPrototypeOf(this).say.call(this)；</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//&#125;；</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对象的方法仅仅是使用函数来代替数据作为对象属性值。 ES6定义了一个内部属性[[HomeObject]]来指明对象方法的归属。</li>
<li>当函数并非一个对象的方法的时候， 不能够使用super</li>
</ul>
</li>
<li><p>对象解构</p>
<ul>
<li>在不使用声明的方式而是直接重新解构赋值的时候， 需要用圆括号包裹解构部分<code>({ type, name } = node);</code>(用于告诉引擎这部分并不是块级语句， 只是一个表达式)</li>
<li>在解构的时候如果表达式右边是<code>null</code>或者<code>undefined</code>， 则会报错</li>
<li>一个值得注意的问题， 看下面的代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = &#123;</span><br><span class="line">  type : <span class="string">'Identifier'</span>,</span><br><span class="line">  name: <span class="string">'foo'</span></span><br><span class="line">&#125;, type = <span class="string">'Literal'</span>, name = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputInfo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value === node)</span><br><span class="line">&#125;</span><br><span class="line">outputInfo(&#123; type, name &#125; = node) <span class="comment">// true // 这里对type和name进行了重赋值， 所以下文的也有改变</span></span><br><span class="line">type <span class="comment">// Idetifier</span></span><br><span class="line">name <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过使用<code>=</code>来指定默认参数， 默认参数只有在缺少该参数， 或者参数值为<code>undefined</code>的时候才会被调用</li>
<li>指定变量名 + 默认值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = &#123;</span><br><span class="line">  type: <span class="string">'Identifier'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">type</span>: lcoalType, <span class="attr">name</span>: localName = <span class="string">'bar'</span> &#125; = node;</span><br><span class="line">localName <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在解构中， 有冒号的地方， 就表示冒号后面的部分为其对应值的展开式（冒号右边即为对应值）</li>
<li>在解构中， 空的花括号是合法的， 但是使用这个并不会有任何效果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">loc</span>: &#123;&#125; &#125; = node; <span class="comment">// 没有任何一个变量被声明。</span></span><br></pre></td></tr></table></figure></li>
<li><p>数组解构</p>
<ul>
<li>最常用的一个便是交换变量值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line">a <span class="comment">// 2</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数组的复制</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 以前</span></span><br><span class="line"><span class="keyword">var</span> arr2 = arr.concat();</span><br><span class="line"><span class="comment">// 现在可以这样写</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [...arr];</span><br></pre></td></tr></table></figure>
<ul>
<li>Rest参数必须要在数组解构的最后， 并且后面不能跟逗号， 否则抛出语法错误</li>
</ul>
</li>
<li><p>函数参数解构</p>
<ul>
<li>111</li>
</ul>
</li>
</ul>
<h1 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h1><ul>
<li><p>Symbol是一种原始数据类型， 并且是唯一一种没有字面量的原始数据类型</p>
</li>
<li><p>因为Symbol是原始类型，所以调用的时候如果使用了new操作符， 将会报错</p>
</li>
<li><p>Symbol接受一个参数来作为其描述， 该参数本身并不能作为属性访问器， 主要用于阅读及调试的便利（作为标识符）</p>
</li>
<li><p>作为原始类型， Symbol是可以使用typeof 操作符来判断类型的</p>
</li>
<li><p>不能对Symbol进行数学运算， 否则会报错， 但是可以对其使用逻辑操作符， 此时， symbol会被转化为true</p>
</li>
<li><p>Symbol不会通过Object.keys()来返回， 可以通过Object.getOwnProperyNames()来获取</p>
</li>
<li><p>当你要创建一个可共享的Symbol的时候， 可以使用Symbol.for()， 它接受唯一的字符串参数作为其标识符。 当使用这个的时候， 会首先查找全局Symbol查看是否注册， 如果注册了， 则直接返回该Symbol， 否则， 则创建一个并注册。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="number">1</span>);</span><br><span class="line">s1 === s2 <span class="comment">// true  注意，因为Symbol接受的参数为字符串， 所以传递数值的时候被转化为字符串了</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1); <span class="comment">// '1'</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2); <span class="comment">// '1' // 字符串</span></span><br></pre></td></tr></table></figure></li>
<li><p>知名Symbols (well-known symbols)（@@create =&gt; Symbol.create）</p>
<ul>
<li>@@hasInstance – instanceof   <code>obj instanceof Array =&gt; Array[Symbol.hasInstance](obj)</code>;</li>
<li>@@isConcatSpreadable  — Array.prototype.concat()   <code>此属性用于表明对象作为concat()方法的参数的时候， 是否把里面的每一项作为单独元素添加进目标数组里</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> col = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'hello'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'world'</span>,</span><br><span class="line">  length: <span class="number">2</span></span><br><span class="line">&#125;, c = [<span class="string">'hi'</span>];</span><br><span class="line">c.concat(col); <span class="comment">// ["hi", Object]</span></span><br><span class="line">col[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">c.concat(col); <span class="comment">// ["hi", "hello", "world"]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>@@iterator — 返回一个迭代器</li>
<li>@@match — String.prototype.match()  — 接受字符串参数， 有匹配则返回数组， 否则返回null</li>
<li>@@replace — String.prototype.repalce() — P149</li>
<li>@@species — 决定一个对象应该怎么生成的构造器</li>
<li>@@split — String.prototype.split();</li>
<li>@@toPrimitive — 返回对象原始值的方法, 接受一个参数<code>hint</code>用来表明应该返回哪种数据类型（三种模式： string, number, default — 在对对象使用 ‘==’或者’+’的时候， 使用默认模式）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">B.prototype[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span> (<span class="params">hint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age + <span class="string">''</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.age + <span class="string">'years old'</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line">+b; <span class="comment">// 12</span></span><br><span class="line"><span class="string">''</span> + b; <span class="comment">// "12years old"</span></span><br><span class="line"><span class="built_in">String</span>(b); <span class="comment">// '12'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>@@toStringTag — 使用Object.prototype.toString.call()或者String.prototype.toString()时返回对象描述</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123; <span class="keyword">this</span>.name = name&#125;</span><br><span class="line"><span class="keyword">var</span>  p = <span class="keyword">new</span> Person(<span class="string">'Jason'</span>);</span><br><span class="line">Person.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">'Person'</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(p); <span class="comment">// "[object Person]"</span></span><br><span class="line">p.toString(); <span class="comment">// "[object Person]"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>@@unsopables — an object whose properties are the names of object properties that should not be included in a with statement.  主要针对 <code>with</code>语句。 P157</li>
<li>重写由well-known symbols定义的方法， 可以将普通对象改变为外来对象从而改变内部默认行为</li>
<li>重写方法需要使用<code>Object.defineProperty()</code></li>
</ul>
</li>
</ul>
<h1 id="Sets-And-Maps"><a href="#Sets-And-Maps" class="headerlink" title="Sets And Maps"></a>Sets And Maps</h1><ul>
<li><p>Set是一个不包含重复值的列表</p>
</li>
<li><p>Map是一个包含键值对的集合</p>
</li>
<li><p><code>Object.create(null)</code>得到的对象是没有原型对象的（原型为null</p>
</li>
<li><p>Set</p>
<ul>
<li>如果多次给Set添加重复值， 那么第一次之后的行为将会被忽略</li>
<li>可以在new Set的时候传递一个数组来对Set进行初始化</li>
<li>方法： add, delete, clear,has,forEach(三个参数： item, index, Set本身， 第一个参数和第二个参数是相同的)</li>
<li>forEach可以接受第二个参数作为回调函数里的this</li>
<li>将set转化为数组： var arr = […set]</li>
</ul>
</li>
<li><p>WeakSet</p>
<ul>
<li>WeakSet只存储弱对象引用（也就是说， 如果除weakSet之外， 没有其他地方引用到该对象的话， 那么weakSet将会删除它）， 不能用于存储原始类型的值。</li>
<li>只有三种方法： add, delete, has</li>
</ul>
</li>
<li><p>Map</p>
<ul>
<li>方法： delete, has, get, set, forEach, clear</li>
<li>初始化： 接受一个数组， 数组里的每一项也是一个数组， 子数组的第一项为key, 第二项为value</li>
</ul>
</li>
<li><p>WeakMap</p>
<ul>
<li>键（key）必须为非null对象， 不能是原始值</li>
<li>这里碰到一个问题</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">t.set(o, <span class="string">'test'</span>);</span><br><span class="line">o = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 按照道理来说， o的引用被删除之后， t的对应键值也应该被删除啊</span></span><br><span class="line"><span class="comment">// 原来是因为垃圾收集的周期性， 当解除引用之后， 只有在下一次垃圾收集的时候才会被删除， 这个可以通过手动调用垃圾收集来查看</span></span><br><span class="line">t; <span class="comment">// WeakMap &#123;Object &#123;&#125; =&gt; "test"&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Set和Map的实例有size属性， 但是WeakSet和WeakMap的实例是没有该属性的。</li>
</ul>
</li>
<li><p>私有对象数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateData = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    privateData.set(<span class="keyword">this</span>, &#123;<span class="attr">name</span>: name&#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> privateData.get(<span class="keyword">this</span>).name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Person</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>Map</code>还是<code>WeakMap</code></p>
<ul>
<li>需要使用对象作为键名的时候最佳选择是<code>WeakMap</code></li>
<li>优先使用<code>WeakMap</code>， 因为它会优化你的内存使用和避免在一个数据不再访问的情况下出现内存泄露的问题。</li>
<li><code>WeakMap</code>的内容拥有非常小的可见性， 因为它只能通过get方法来访问， 而不具有forEach, clear()， size等方法或者属性来管理内容， 如果你需要知道他们的容量的话， 那么<code>Map</code>会更加合适， 但是此时需要注意内存的使用情况</li>
<li>如果你需要使用非对象作为键名的话， 那么两者之间你只能选择<code>Map</code></li>
</ul>
</li>
<li><p><code>Set</code>, <code>Map</code>, <code>WeakSet</code>, <code>WeakMap</code>判断是否是根据<code>Object.is</code>来判断是重复键的</p>
</li>
</ul>
<h1 id="迭代器-Iterator-和生成器-Generator"><a href="#迭代器-Iterator-和生成器-Generator" class="headerlink" title="迭代器(Iterator)和生成器(Generator)"></a>迭代器(Iterator)和生成器(Generator)</h1><ul>
<li>迭代器</li>
<li>生成器<ul>
<li>生成器是一种能够返回迭代器的特殊函数</li>
<li>在<code>function</code>关键字的后面使用星号来进行标识</li>
<li><code>yield</code>关键字可以指定每次迭代器应该返回的值。</li>
<li>每次执行完一次<code>yield</code>之后， 函数都会停止执行， 在下一次next()的时候， 再恢复执行</li>
<li>生成器表达式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = items.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> items[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>不能使用箭头函数创建生成器</li>
</ul>
</li>
<li>for of<ul>
<li>该语句将会着眼于集合内容而非索引(for key of arr, 那么key则为索引上的那个值， 而非索引本身)</li>
<li>对于没有实现iterator接口， 及null, undefined使用for..of将会报错</li>
</ul>
</li>
<li>访问默认迭代器<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span><span class="string">`,2, 3, 4, 5, 6];</span></span><br><span class="line"><span class="string">var i = arr[Symbol.iterator]();</span></span><br><span class="line"><span class="string">i.next(); // Object &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>检测是否实现iterator接口<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建iterable<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = &#123;</span><br><span class="line">  items: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator] () &#123; <span class="comment">// 注意星号和方括号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> collection) <span class="built_in">console</span>.log(value);</span><br><span class="line"><span class="comment">// 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure></li>
<li>集合的Iterator<ul>
<li>Array, Map, Set的实例是默认实现了Iterator接口的</li>
<li>上述三种类型都有三种相同的内置迭代器</li>
<li>entries()  — 返回键值对</li>
<li>values()  — 返回值</li>
<li>keys() — 返回键</li>
<li>使用的时候都是`for (let item of arr.entries())</li>
<li>每一种集合都有一种默认的迭代器， Array和Set的是values(), Map的是entries()`</li>
<li>字符串迭代器</li>
<li>NodeList迭代器</li>
</ul>
</li>
<li>给迭代器传递参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">add</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> second + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = add();</span><br><span class="line">a.next(); <span class="comment">// Object &#123;value: 1, done: false&#125;</span></span><br><span class="line">a.next(<span class="number">4</span>); <span class="comment">// Object &#123;value: 6, done: false&#125;</span></span><br><span class="line">a.next(<span class="number">5</span>); <span class="comment">// Object &#123;value: 8, done: false&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>但是第一次迭代的时候给next()传递参数是无效的</strong><br>在生成器里面， 第一次迭代之后yield的返回值由调用next()的时候传递的参数决定。</p>
<ul>
<li>迭代器错误这里还有点问题 — P202</li>
<li>生成器里的return语句<br>生成器里一旦包含return语句， 那么在到达那里的时候， 就会直接结束迭代器的迭代状态， 也就是说，在这次的产出值里， done的值为true, 无论迭代是否完成， 如果return 提供了值， 那么value将会是该值， 否则为undefined<br>使用return指定的值只能使用1次， 下次调用next()方法的时候， 其值会被重置成undefined;</li>
</ul>
<p><strong>所有被return指定的值都不会出现在for…of和扩展操作符中， 因为此时的done的状态是true, 而一旦done为true， 他们就不会读取value</strong></p>
<ul>
<li>生成器代理<ul>
<li>在一个生成器里yield 另外一个生成器， 注意的是， yield的后面也要跟星号。</li>
<li>此时他们会按照次序依次执行。</li>
<li>此时， 子生成器里的return的值会作为yield该生成器的值</li>
<li>Generator Task Runner P212</li>
</ul>
</li>
</ul>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><ul>
<li><p>class的contructor方法等价于构造器</p>
</li>
<li><p>class只是一颗语法糖</p>
</li>
<li><p>class声明不同于函数声明， 没有声明提升， 它类似于let声明（所以重复声明会报错）</p>
</li>
<li><p>class里的代码都会运行于严格模式下</p>
</li>
<li><p>所有的方法都是不可枚举的。</p>
</li>
<li><p>所有的方法都不具有[[construct]]内部属性， 所以不能使用new操作符</p>
</li>
<li><p>对使用class声明的构造器， 没有使用new操作符， 会报错</p>
</li>
<li><p>在class内部方法内重写class的名称将会抛出错误</p>
</li>
<li><p>含有name属性的class<br>其name属性只能在class内部方法内使用</p>
</li>
<li><p>访问器属性</p>
<ul>
<li>私有属性应该在constructor里面创建， 同时也可以在原型上定义访问器属性。</li>
<li>要创建getter， 使用关键字get， 后面跟上空格 ， 再加上标识符, getter属性是不可枚举的</li>
</ul>
</li>
<li><p>class 里面使用生成器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Col = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator] () &#123;</span><br><span class="line">    <span class="keyword">yield</span> *<span class="keyword">this</span>.items.values();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Col();</span><br><span class="line">c.items.push(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">[...c]; <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li>
<li><p>静态成员</p>
<ul>
<li>使用static, 静态成员是直接定义在构造器上的方法， 与不受实例影响， 通常情况下， 一个构造器里可能调用， 但是和实例没有直接关系的方法， 就可以使用静态方法。</li>
<li>静态成员不能被实例访问， 只能直接在class内部访问静态成员</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li>类通过使用相似的<code>extends</code>关键字来实现从指定的构造器继承 。 通过在constructor里使用super()关键字， 可以访问基类。</li>
<li>在继承当中， 如果没有指定constructor ， 那么super()将会自动调用</li>
</ul>
</li>
<li><p>使用super的时候需要注意西夏几点：</p>
<ul>
<li>只能在派生类（继承）当中使用super</li>
<li>在constructor里面使用this之前，必须先调用super()以初始化this</li>
<li>避免调用suepr的唯一方法就是在constructor里面返回一个对象。</li>
</ul>
</li>
<li><p>重写父类方法</p>
<ul>
<li>通过在子类中使用与父类相同的方法名， 就可以重写父类的方法</li>
<li>可以通过super来访问父类的方法，如： <code>super.getName()</code></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue JSX 属性透传的问题</title>
    <url>/2020/03/13/Vue%20JSX%20%E5%B1%9E%E6%80%A7%E9%80%8F%E4%BC%A0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>参见以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createButtons</span> = (<span class="params">h, buttons</span>) =&gt; <span class="title">props</span> =&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">    &lt;span style=<span class="string">"display: flex; justify-content: space-between;"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt; </span><br><span class="line">      &#123;buttons.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">        &lt;mtd-button</span><br><span class="line">          &#123;...&#123; <span class="attr">attrs</span>: item &#125;&#125;</span><br><span class="line">          key=&#123;index&#125;</span><br><span class="line">          onClick=&#123;() =&gt; item.onClick(props)&#125;</span><br><span class="line">          disabled=&#123;item.__disabled&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &#123;item.text&#125;</span><br><span class="line">        &lt;<span class="regexp">/mtd-button&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>span&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">createButtons(<span class="keyword">this</span>.$createElement, [</span><br><span class="line">  &#123;</span><br><span class="line">    text: <span class="string">'修改'</span>,</span><br><span class="line">    onClick: <span class="keyword">this</span>.handleModify,</span><br><span class="line">    size: <span class="string">'small'</span>,</span><br><span class="line">    disabled: <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> auditStatus.isOffline(props.row.status)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>编译后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">renderedButtons.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> item.disabled === <span class="string">'function'</span>) &#123;</span><br><span class="line">        item.__disabled = item.disabled(props);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> item.disabled === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">        item.__disabled = item.disabled;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">"span"</span>, &#123;</span><br><span class="line">      <span class="string">"style"</span>: <span class="string">"display: flex; justify-content: space-between;"</span></span><br><span class="line">    &#125;, [renderedButtons.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> h(<span class="string">"mtd-button"</span>, &#123;</span><br><span class="line">        <span class="string">"attrs"</span>: _objectSpread(&#123;&#125;, item, &#123;</span><br><span class="line">          <span class="string">"disabled"</span>: item.__disabled</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="string">"key"</span>: index,</span><br><span class="line">        <span class="string">"on"</span>: &#123;</span><br><span class="line">          <span class="string">"click"</span>: <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> item.onClick === <span class="string">'function'</span>) &#123;</span><br><span class="line">              item.onClick(props);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, [item.text]);</span><br><span class="line">    &#125;)]);</span><br></pre></td></tr></table></figure>

<p>最后，在我们点击修改按钮的时候，控制台报错：<br><img align=left height=44 width=661 data-src="https://cdn.nlark.com/yuque/0/2020/png/434020/1584069608768-4858754d-5ab5-49f5-9d04-4e7c7f806705.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Uncaught <span class="built_in">SyntaxError</span>: <span class="built_in">Function</span> statements <span class="built_in">require</span> a <span class="function"><span class="keyword">function</span> <span class="title">name</span></span></span><br></pre></td></tr></table></figure>

<p>在这里createButtons 中的某一项传递了onClick这个参数，那么在对应的渲染函数里面，最后传递给组件的是什么样的呢？</p>
<img align=left height=236 width=458 data-src="https://cdn.nlark.com/yuque/0/2020/png/434020/1584069494907-9d16d049-804e-4233-aee2-cd6089530db5.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" />

<p>handleModify 很好理解，就是我们希望绑定的事件，但是在上面的listeners里面，还添加了click事件，其对应的函数为<br><img align=left height=183 width=358 data-src="https://cdn.nlark.com/yuque/0/2020/png/434020/1584069576328-6b080a8d-1272-44ed-b2fa-6549000dbc63.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /></p>
<p>因此，上面的方式，最后会把 onClick 封装到 attrs里面。</p>
<p>在 Vue 组件挂载会后，首次更新时，Vue 会把相应的属性更新到 DOM 上.<br><img align=left height=566 width=1243 data-src="https://cdn.nlark.com/yuque/0/2020/png/434020/1584094932644-aef4e315-6d46-4990-a672-57ceadae838a.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /></p>
<p>因此，最后会调用 ele.setAttribute(key, value) 来设置组件的属性。这里的key value 都应该是一个<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0RPTVN0cmluZw==">DOM String<i class="fa fa-external-link-alt"></i></span>。在这里的场景下， key 是对应的 onClick 字符串，而 value 是一个函数，它被定义为了 Vue 组件上的一个方法。而 Vue 在实例化组件的时候，通过initMethods方法，把对应的 method 通过bind 的方式绑定了vm的上下文。因此，这里的 value，最后是一个Bound function。因此这里会把相应的函数转换为DOM String，具体的转换方法没有找到相应的文档，但是从转换结果来看，是调用了函数的toString方法。而bind返回的函数，它的toString方法，最后会返回一个表示native代码的字符串，也就是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; [native code] &#125;</span><br></pre></td></tr></table></figure>

<p>因此，最后输出到html里的就变成了以下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"function () &#123; [native code] &#125;"</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们知道，在一个元素定义了onclick属性的情况下，点击的时候，会将其属性值当作js脚本来执行。因此，当我们点击按钮的时候，会执行上面的脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; [native code] &#125;</span><br></pre></td></tr></table></figure>

<p>然而这个脚本是非法的，不说函数体，定义一个函数有函数表达式和函数声明两种方式，而上面的这种方式只能作为匿名函数被调用，在这里被当成了函数声明，因此就报错了。<br><img align=left height=33 width=721 data-src="https://cdn.nlark.com/yuque/0/2020/png/434020/1584096578955-c936ce31-0948-4739-84c2-f977fa0a900a.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /><br>Vue updateAttrs<br>el.setAttribute(key, value)</p>
<p>总结：<br>当出现问题并且不知道导致问题发生的因素时，应先通过<strong>二分法</strong>快速定位到导致问题的代码，然后通过<strong>控制变量，减少场景的影响因子，在控制变量的时候，更需要注意双边其他因子的一致性，</strong>找到问题出现的原因，待解决问题后，再寻根溯源，找到产生问题的根本因素。</p>
<p>参考： </p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI2hhbmRsZXItb25jbGljaw==">https://html.spec.whatwg.org/multipage/webappapis.html#handler-onclick<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93M2MuZ2l0aHViLmlvL3VpZXZlbnRzLyNldmVudC10eXBlLWNsaWNr">https://w3c.github.io/uievents/#event-type-click<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <tags>
        <tag>每天学习一丢丢~</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome开发工具timeline使用</title>
    <url>/2016/06/15/chrome%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7timeline%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3Rvb2xzL2Nocm9tZS1kZXZ0b29scy9wcm9maWxlL2V2YWx1YXRlLXBlcmZvcm1hbmNlL3RpbWVsaW5lLXRvb2w=">原文地址<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
  </entry>
  <entry>
    <title>electron no path.txt的解决办法</title>
    <url>/2016/07/12/electron-no-path-txt%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLXByZWJ1aWx0L2lzc3Vlcy83Ng==">原文地址<i class="fa fa-external-link-alt"></i></span></p>
<p>进入目录<code>electron-prebuilt</code>然后<code>node install.js</code></p>
]]></content>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>JS控制光标移动</title>
    <url>/2016/07/04/JS%E6%8E%A7%E5%88%B6%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8/</url>
    <content><![CDATA[<p>网上的那些人也真的是够了， 复制粘贴什么的都习以为常， 就算是抄一个东西， 难道不也该先验证一下人家的是不是对的么， 走网上搜一个光标移动位置的问题， 搜索结果一帕拉， 而且都是惊人地相似， 但是放到浏览器里面， 根本就不能够跑！！！！！！！！！！！！！！</p>
<a id="more"></a>
<p>然后自己最后还是老老实实地看书， 恩， 找到了一个方法哈。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sel = <span class="built_in">window</span>.getSelection(),</span><br><span class="line">  range = <span class="built_in">document</span>.createRange(),</span><br><span class="line">  div = $(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line">range.selectNodeContents(div);</span><br><span class="line">sel.addRange(range);</span><br><span class="line">sel.collapseToEnd();</span><br></pre></td></tr></table></figure>


<p>这个针对<code>contenteditable</code>元素是有效的， 但是在<code>textarea</code>下， 使用<code>range</code>好像选不了其范围， 所以不能够操作， 不知道是不是方法错了， 不过在选中了文本框文本的情况下， 还是可以移动光标的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> textarea = $(<span class="string">'textarea'</span>);</span><br><span class="line">textarea.select();</span><br><span class="line"><span class="comment">// 也可以使用这段代码来设置选中范围， 然后就方便控制其光标位置了。</span></span><br><span class="line"><span class="comment">// textarea.setSelectionRange(0, 12); // 选中文本框内容的0, 12</span></span><br><span class="line"><span class="built_in">window</span>.getSelection().collapseToStart(); <span class="comment">// 光标移动到开始位置</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>base64了解一下</title>
    <url>/2019/12/22/base64%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<p>代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzM3NDYzMjg5Ny9kZW1vcy9ibG9iL21hc3Rlci9lbmNyeXB0L2Jhc2U2NC5qcw==">https://github.com/374632897/demos/blob/master/encrypt/base64.js<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a> 

<p>在平时的工作中，base64使用场景比较多，比如文件上传。那么，base64到底是个什么东西？</p>
<p>通常来讲，我们平时使用的字符集是utf-8，而对于JavaScript中的binary string 而言，其使用的是ASCII扩展字符集。标准的ASCII字符集只有128个字符（2^7），而ASCII扩展字符集则包含了256个字符。</p>
<p>使用String.prototype.charCodeAt 方法，可以获取到相应字符的码点。</p>
<p>而base64，其字面意思就是使用64个字符来对输入内容进行描述（实际上应该是65个字符，A-Za-z0-9，以及+/总共64个字符，但是最后可能还需要使用=进行补位）。对于二进制字符串来说，可能包含256个字符，所以当使用base64来对二进制字符串进行编码的时候，就需要将256个字符描述的内容使用64个字符来进行描述。</p>
<p>简单来讲，就是<strong>把3个8bit的数据用4个6bit的数据来进行表示。</strong></p>
<p>我们知道， 256 = 2 ^8，64 = 2 ^6, 因此当我们把二进制字符串的每个字符使用二进制来进行描述，并确保其填充到8位之后，再将相应的字符串以6位为单位进行分组，针对分组后的字符串再进行填充，填充到8位，这样就可以用64位字符编码来对其进行描述了。</p>
<p><strong>在电子邮件中，每隔76个字符，还需要添加一个回车来进行换行。</strong></p>
<p>以下以字符串“He”为模板进行步骤描述：</p>
<ol>
<li><p>输入字符串 ‘He’</p>
</li>
<li><p>针对每个字符串，调用<code>String.prototype.charCodeAt</code>方法，获取其码点   </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> charsCode = <span class="string">'He'</span>.split(<span class="string">''</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> item.charCodeAt(<span class="number">0</span>))</span><br><span class="line"><span class="comment">// [72, 101]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将获取到的码点用二进制来表示，并填充成8位</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> binaryAry = charsCode.map(<span class="function"><span class="params">item</span> =&gt;</span> item.toString(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// ["1001000", "1100101"]</span></span><br><span class="line"><span class="comment">// ["01001000", "01100101"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将获得的二进制字符串数组进行合并并以6个为单位进行分组，在这里需要注意的是，<strong>如果合并后的二进制字符串不是3的整数的话，那么需要在末尾用0来进行填充</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">"01001000"</span>, <span class="string">"01100101"</span>]</span><br><span class="line"><span class="string">'0100100001100101'</span>.length <span class="comment">// 16</span></span><br><span class="line"><span class="string">'010010000110010100'</span> <span class="comment">// 末尾填充</span></span><br><span class="line"><span class="comment">// 010010 000110 010100</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><del>针对分组后的字符串，使用0将其填充到8位</del></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 010010 000110 010100</span></span><br><span class="line"><span class="comment">// 00010010 00000110 00010100</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将最后得到的二进制字符串转换为十进制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 010010 000110 010100</span></span><br><span class="line"><span class="string">'010010 000110 010100'</span>.split(<span class="string">' '</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseInt</span>(item, <span class="number">2</span>))</span><br><span class="line"><span class="comment">// [18, 6, 20]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将得到的十进制数字从base64字母表中进行查找，得到对应的字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.map(<span class="function"><span class="params">item</span> =&gt;</span> b64Ary[item])</span><br><span class="line"><span class="comment">// ["S", "G", "U"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>判断得到的结果是否为4的倍数，如果不是，使用=号进行补位 或者说 原数据的长度是否为3的倍数，如果不是则补位（为1，则为两个==，为2则为1个=）</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ["S", "G", "U"]</span></span><br><span class="line"><span class="comment">// SGU</span></span><br><span class="line"><span class="comment">// SGU=</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>最后，转换完成，将 He 转换为了 SGU=</p>
<p>从上面的步骤来看，可能我们会有以下疑问：</p>
<ul>
<li>第4步中为什么合并后的字符串需要是3的倍数？</li>
</ul>
<p>因为需要将3个字节编码为4个字节</p>
<ul>
<li>第8步中为什么最后的base64字符串需要为4的倍数？</li>
</ul>
<p>同上，最后一段base64编码代表的是若干个字符，而编码规则便是以4为单位的</p>
<ul>
<li>以上考虑的是针对二进制的，那么针对utf-8的字符串，要做base64处理的话，应该怎么做呢？</li>
</ul>
<p><strong>在使用base64编码后，编码后的数据相比于原数据会多出大概1/3的内容，因为原本的3个字符变成了4个字符，因此（4 - 3）/ 3 = 1/3</strong><br>**<br>另外一种实现方式：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvYmFzZTY0L2Jsb2IvbWFzdGVyL3NyYy9iYXNlNjQuanM=">https://github.com/mathiasbynens/base64/blob/master/src/base64.js<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQWxnb3JpdGhtX0ltcGxlbWVudGF0aW9uL01pc2NlbGxhbmVvdXMvQmFzZTY0I0phdmFzY3JpcHQ=">带注释的版本<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> encode = <span class="function"><span class="keyword">function</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">		input = <span class="built_in">String</span>(input);</span><br><span class="line">		<span class="keyword">if</span> (<span class="regexp">/[^\0-\xFF]/</span>.test(input)) &#123;</span><br><span class="line">			<span class="comment">// Note: no need to special-case astral symbols here, as surrogates are</span></span><br><span class="line">			<span class="comment">// matched, and the input is supposed to only contain ASCII anyway.</span></span><br><span class="line">			error(</span><br><span class="line">				<span class="string">'The string to be encoded contains characters outside of the '</span> +</span><br><span class="line">				<span class="string">'Latin1 range.'</span></span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> padding = input.length % <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">var</span> output = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">var</span> position = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">var</span> a;</span><br><span class="line">		<span class="keyword">var</span> b;</span><br><span class="line">		<span class="keyword">var</span> c;</span><br><span class="line">		<span class="keyword">var</span> buffer;</span><br><span class="line">		<span class="comment">// Make sure any padding is handled outside of the loop.</span></span><br><span class="line">		<span class="keyword">var</span> length = input.length - padding;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (++position &lt; length) &#123;</span><br><span class="line">			<span class="comment">// Read three bytes, i.e. 24 bits.</span></span><br><span class="line">			a = input.charCodeAt(position) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">			b = input.charCodeAt(++position) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">			c = input.charCodeAt(++position);</span><br><span class="line">			buffer = a + b + c;</span><br><span class="line">			<span class="comment">// Turn the 24 bits into four chunks of 6 bits each, and append the</span></span><br><span class="line">			<span class="comment">// matching character for each of them to the output.</span></span><br><span class="line">			output += (</span><br><span class="line">				TABLE.charAt(buffer &gt;&gt; <span class="number">18</span> &amp; <span class="number">0x3F</span>) +</span><br><span class="line">				TABLE.charAt(buffer &gt;&gt; <span class="number">12</span> &amp; <span class="number">0x3F</span>) +</span><br><span class="line">				TABLE.charAt(buffer &gt;&gt; <span class="number">6</span> &amp; <span class="number">0x3F</span>) +</span><br><span class="line">				TABLE.charAt(buffer &amp; <span class="number">0x3F</span>)</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (padding == <span class="number">2</span>) &#123;</span><br><span class="line">			a = input.charCodeAt(position) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">			b = input.charCodeAt(++position);</span><br><span class="line">			buffer = a + b;</span><br><span class="line">			output += (</span><br><span class="line">				TABLE.charAt(buffer &gt;&gt; <span class="number">10</span>) +</span><br><span class="line">				TABLE.charAt((buffer &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x3F</span>) +</span><br><span class="line">				TABLE.charAt((buffer &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0x3F</span>) +</span><br><span class="line">				<span class="string">'='</span></span><br><span class="line">			);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (padding == <span class="number">1</span>) &#123;</span><br><span class="line">			buffer = input.charCodeAt(position);</span><br><span class="line">			output += (</span><br><span class="line">				TABLE.charAt(buffer &gt;&gt; <span class="number">2</span>) +</span><br><span class="line">				TABLE.charAt((buffer &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0x3F</span>) +</span><br><span class="line">				<span class="string">'=='</span></span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> output;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0">维基百科 - Base64<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <tags>
        <tag>每天学习一丢丢~</tag>
      </tags>
  </entry>
  <entry>
    <title>关于overflow-x的一点小东西</title>
    <url>/2016/06/12/%E5%85%B3%E4%BA%8Eoverflow-x%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E4%B8%9C%E8%A5%BF/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9qc2ZpZGRsZS5uZXQv">DEMO地址<i class="fa fa-external-link-alt"></i></span></p>
<p>绝对定位元素虽然脱离文档流了， 但是依然会受到父元素或者祖先元素的<code>overflow</code>属性的影响。</p>
<a id="more"></a>

<p>如上面demo中所示， 子元素是绝对定位的， 并且其宽度是超出了父元素的宽度的， 正常情况下， 超出部分是可以看到的， 但是在给父元素设置<code>overflow-auto</code>之后， 父元素便会出现滚动条。</p>
<p>o(╯□╰)o  至于原因。。 想不通， 如果说<code>overflow:hidden</code>使得子元素超出父元素的部分能够隐藏的话， 还能够理解， 但是<code>overflow-x: auto</code>出现滚动条很明显应该是因为父元素的宽度不够内容宽度，而绝对定位本身是脱离文档流的， 所以不应该会撑开父元素宽度啊。。。。不理解不理解。   </p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>关于最近的一些事</title>
    <url>/2016/07/04/%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="随便写的一些东西"><a href="#随便写的一些东西" class="headerlink" title="随便写的一些东西"></a>随便写的一些东西</h1><h2 id="关于造轮子"><a href="#关于造轮子" class="headerlink" title="关于造轮子"></a>关于造轮子</h2><p>针对造轮子这个问题， 业界的说法是， 永远不要重复造轮子。因为造轮子和维护轮子的过程是相当痛苦和费时的。 当然， 对我来说， 我觉得只是玩一玩的话， 偶尔造几个轮子还是不错的。 最重要的是， 通过造轮子这个过程， 能够学习到很多东西，同时也能巩固自己所学习到的知识 。</p>
<a id="more"></a>


<p>其实我是有强迫症的， 有时候业务上有某个需求了， 虽然有现成的轮子可以用， 但是如果直接引用轮子的话，会造成很多冗余的代码， 毕竟不少的轮子为了满足大众， 功能设计的都是非常全面的， 很多情况下这样都挺不错， 然而偏偏我很挑。</p>
<p>不过其实关于挑这个话题， 我感觉自己也是在装逼， 毕竟要真说冗余代码的话， 项目里使用<code>babel</code>, 使用<code>webpack</code>之后， 代码覆盖率是明显下降了的， 冗余代码量非常之大。所以就算为了满足需求引入一个轮子的话， 所谓的多余的代码和项目里的冗余代码比起来其实是完全不值一提的， 当然， 更不要说人为的因素了，比如项目里的大量的未抽取出来的重复代码， 以及逻辑的复杂化（明明可以通过更简单的逻辑来达到目的）造成的冗余代码。所以对我来说， 冗余代码东西这个完全就只是一个借口， 我只是单纯地享受那种自己造完一个轮子之后的快感而已（虽然只是小轮子）。值得一提的是， 这种自己造的轮子在稳定性方面肯定是不如现有轮子的， 但是在定制方面却是省事多了， 毕竟造轮子的初衷便是为了满足业务需求， 所以即使后期需求变更了， 改变起来也会比较快。</p>
<h2 id="关于一个小工具"><a href="#关于一个小工具" class="headerlink" title="关于一个小工具.."></a>关于一个小工具..</h2><p>周末的时候去买了菜买了米， 但是我不知道我的上一袋米是什么时候买的， 吃了多久，我一个月用了多少钱， 怎么花的， 花在了哪些方面。这些我都不知道。 说起来， 其实大学的时候自己每周都会记账的， 那时候还会发在空间里面让小伙伴瞅瞅我到底有多省， 顺带装装逼。 至于到底有多省呢， 我记得最少的一次我一个月只用了300元。也是惭愧， 不是我没钱（不， 确实是没钱）， 是我钱都花去买手机， 还是买游戏装备上去了？ 忘了。 总之就是没钱， 所以才省 。 有人说我咋不去找兼职呢， 其实我是找过的， 大学里面第一次去找兼职还是翘课去的， 像我这种尊重师长从不逃课的好孩纸啊， 要不是真的没钱了是绝对不会逃课的， 所以我这次兼职怎么也得赚回个本儿吧， 兴致冲冲的我就去了。 结果我6点出门， 路上堵啊堵啊堵啊！！！！9点才到那地儿， 打电话给那边， 也不应我， 打了好几次才接，结果告诉我去迟了，人家都已经招满了， 我了个大槽也是醉了， 好歹我是翘课去的， 天公也太不给力了。 于是我便满腹忧伤。后来又尝试去找兼职， 结果都是让半兼职卡的， 我特么有钱办兼职卡还找个毛工作啊！！！！ 一群骗纸。 所以到现在， 我人生里挣的第一笔钱还是小学的时候去抠的扎尔根卖掉赚的钱， 好像还是20块还是多少的来着， 那可是0几年的20块啊， 都够我买200根辣条儿了。</p>
<p>o(╯□╰)o  貌似扯远了:smirk:。总之我平时候还是比较省钱的， 然而现在我却对自己花了多少钱怎么花的一无所知， 所以我觉得很有必要开始记账， 而使用手机啥的。。太憋屈了， 更别说用word, excel之类的了， 我只是单纯的想记个账而已， 哪里需要用那么高大上的东西， 然后就用周末的时间写了个记账的网页。说起来原本准备用这个周末来好好学习一下<code>canvas</code>的， 结果学着学着就走心了， 然后就折腾起了这玩意儿。最开始的时候是准备用数据库来存放数据的， 但是后来又想到我家里没网， 当然最重要的是我没有钱租主机买空间，光是买个域名我就心疼了好久呢。 所以如果使用数据库的话， 那么就只有在我本地上才能跑了， 这样子显然是不行的， 所以我决定使用<code>localStorage</code>来保存数据， 虽然麻烦了一点， 不过也只是在最开始写的时候会比较麻烦，之后还是比较轻松的。说到这里， 数据结构的设计又是一个问题了， 不过现在随便弄了弄， 将就着用吧。后期直接使用<code>electron</code>来打包成二进制文件了， 其实我现在就想打包， 但是刚换了硬盘， 电脑上也没装<code>electron</code>。  其实弄这个的初衷是， 我想知道5kg的米够我吃多久， 1.8L的油够我用多久， 然后和平时买的菜啊啥的杂七杂八的花费作个对比， 看看下次买米买油的时候是该挑好的买， 还是挑便宜的买。</p>
<h2 id="关于专注"><a href="#关于专注" class="headerlink" title="关于专注"></a>关于专注</h2><p><code>专注</code>这个话题我已经提了不止一遍了， 每次提到它的时候我总是会提到<code>控制力</code>, 好吧， 再来呻吟一句， 我的控制力是真的真的弱爆了！！！！！ 至于专注力这个东西， 则是要看情况， 如果是在码代码的情况下， 专注度还是比较高的， 而如果是在看书（技术书）的时候， 真的很容易很容易分心。 比如前面提到的， 我这周本来是准备学<code>canvas</code>的， 结果学着学着我就搞起了另外的小玩意儿。 总之看书的时候就是不专注， 这个书专指技术书， 如果是小黄书的话， 我看得可认真了。 我觉得的原因吧， 大概就是自己现在还利用吃饭的时间来看小说， 这样导致的一个问题是， 经常小说看的过瘾了， 再看技术书的话， 感觉就枯燥乏味， 我试了下， 如果吃饭的时候看的是技术书的话， 那么之后几十分钟内一直都会专注于技术书。 所以以后是不是应该禁掉小说， 吃饭的时候也好好看书哪 ？ 刚刚开始接触前端的那段时间， 吃饭的时候就是一直在看<code>JavaScript高级程序设计</code>的来着， 感觉还不错， 我觉得现在也应该好好好好好好看书， 吃饭的时候也看， 不然真怕自己忍不住看了小黄书， 然后忍不住干了坏事。</p>
<h2 id="关于读书"><a href="#关于读书" class="headerlink" title="关于读书"></a>关于读书</h2><p>我学习的时候， 大概情况是先看一遍基础的知识， 比如走<code>w3school</code>上面看， 然后看一遍视频， 然后再看一遍基础知识， 然后看文档， 中间穿插着码代码。 现在的话， 感觉看视频这东西确实是不如看书。 毕竟看书的话， 上面的知识点会比较全面，当然，前提是选对了书。现在我这书桌上放着这样一些书， 按购买顺序来排列的话<code>JavaScript高级程序设计（第三版）</code>、<code>锋利的jQuery</code>、<code>Javascript设计模式与开发实践</code>、<code>HTTP权威指南</code>、<code>HTML5 Canvas核心技术</code>、<code>算法（第4版）</code>、<code>黑客与画家</code>、<code>数学之美</code>、<code>深入浅出Nodejs</code> 。 其实书这种东西应该按需购买， 买一本看一本， 搞定了之后再谈其他。 如果要是一次性买了比较多的话， 就很容易分心， 一会儿看这本， 一会儿看那本， 然后。。然后。。。反正我这样弄了之后整个人是越来越烦躁了， 总想着， 我还有多少多少书没有看完啊， 好烦啊好烦啊。</p>
<h2 id="关于语言"><a href="#关于语言" class="headerlink" title="关于语言"></a>关于语言</h2><p>对于这个话题， 我觉得我这种大学毕业之后才开始正式学编程的人是没有资格来讨论的， 但是我还是想说说。 一句话，贪多嚼不烂啊嚼不烂。 但是没办法， 有时候就是想学， 就算自己现在本家语言也还没搞定的情况下也想学。 劝也劝不住， 自个儿就尽管往火坑里跳吧。 我学了啥呢， 其实也不多， 就<code>php</code>, <code>JAVA</code>, 如果<code>mysql</code>和<code>mongodb</code>也算的话，那就勉勉强强加上也成。 当然， 我只是说我学过哈， 真的只是学过而已。 比如你现在要问我<code>JAVA</code>里的泛型是什么， 我这就一脸懵逼了， 更别说<code>php</code>里的几千个内置函数了。 总之总之， 我是把自己推入了一个坑， 这种东西就算当时学了， 但是没有使用场景的话， 还是会很快忘记的。 不过好处也是有的， 我感知最明显的是， 最开始其实我是不喜欢用<code>ES6</code>的<code>class</code>的， 但是现在我没事儿老爱用这破玩意儿了，而且用起来也确实是方便多了。 笑cry.. 关于学<code>JAVA</code>这件事， 其实我一开始是不想学的， 也没准备学，然而买的算法书里面用到的语言就是<code>JAVA</code>， 虽然用<code>JS</code>也能实现大部分的算法， 但是这人强迫症一犯硬要跳坑你是拉也拉不住的。 那当初谁说的来着， 会的语言越多找媳妇儿越容易， 毕竟会的语言多了， 就相当于扩展了找媳妇儿的面向了嘛 ， 我本来是抱着这样的心态去学其他语言的， 然而然而，长相永远是硬伤。</p>
<h2 id="关于网络"><a href="#关于网络" class="headerlink" title="关于网络"></a>关于网络</h2><p>我断网了， 给自己的理由是能上网的话太容易分心， 难得有个周末应该保持专注好好看书才对。 好吧， 这理由就是用来哄鬼的， 谁要是真信了， 那我罪过可就大了， 其实我就是没钱交网费。手动对眼（换了硬盘之后输入法设置也变了， 打不了对眼了， 其实服务器上保存有我的快捷键的， 可是奈何我没网）。扯远了， 断网了之后怎么说呢， 有好有坏吧。 好的一点在于确实能够在一定程度上保持专注， 不会时不时地刷微博， 刷空间， 看小黄书， 看小黄片儿了， 因为想看也没得看啊， 笑cry 。 不过坏处在于， 哎呀窝草， 想下个包儿还得等去了公司了下到U盘里了再转到我的电脑里。 这就是不方便， 还有查资料查文档方面也是不方便。 总的来说是有好有坏吧， 现阶段看来的话， 还是利大于弊的。</p>
<h2 id="关于翻译"><a href="#关于翻译" class="headerlink" title="关于翻译"></a>关于翻译</h2><p>发现表达这种东西对我来说实在实在是太困难了。要把自己脑袋里想的东西表述出来让别人知道的话， 真的是太要命了。 我翻译一篇英文文档的时间都够我看四五篇类似的文档了， 因而我每次的翻译都是无疾而终， 翻译到一半就搞不下去了。 知道翻译的困难， 所以特别佩服那些默默为社区翻译文档的童鞋们， 你们真的是我的偶像 + 榜样啊！！！！！听说上次有个哥们儿把<code>W3C</code>的<code>HTML</code>规范给搞出来了， 也是666。 你们都是一群值得尊敬的人。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感觉<code>FarBox</code>还是挺不错的， 挺好用的<code>markdown</code>编辑器。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>伪类和伪元素的区别</title>
    <url>/2020/04/14/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><a name="fpf9D"></a></p>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTL1BzZXVkby1jbGFzc2Vz">伪类<i class="fa fa-external-link-alt"></i></span></h2><p><a name="WYyXj"></a></p>
<a id="more"></a> 
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>伪类（pseudo）是添加到选择器的关键字，指定<strong>要选择的元素的特殊状态</strong></p>
<blockquote>
<p>The pseudo-class concept is introduced to permit selection based on information that lies outside of the document tree or that cannot be expressed using the other simple selectors.<br>A pseudo-class always consists of a “colon” (<code>:</code>) followed by the name of the pseudo-class and optionally by a value between parentheses.</p>
</blockquote>
<blockquote>
<p>Pseudo-classes are allowed in all sequences of simple selectors contained in a selector. Pseudo-classes are allowed anywhere in sequences of simple selectors, after the leading type selector or universal selector (possibly omitted). Pseudo-class names are case-insensitive. Some pseudo-classes are mutually exclusive, while others can be applied simultaneously to the same element. Pseudo-classes may be dynamic, in the sense that an element may acquire or lose a pseudo-class while a user interacts with the document.</p>
</blockquote>
<p><a name="97aHJ"></a></p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><table>
<thead>
<tr>
<th>伪类</th>
<th>含义</th>
<th></th>
<th></th>
<th>demo</th>
</tr>
</thead>
<tbody><tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzphY3RpdmU=">:active<i class="fa fa-external-link-alt"></i></span></td>
<td>被用户激活的元素，用鼠标交互时，代表的是用户按下按键和松开按键之间的时间；在多键鼠标的系统中，<strong>只匹配主键</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpob3N0">:host<i class="fa fa-external-link-alt"></i></span></td>
<td>CSS伪类选择包含其内部使用的CSS的shadow DOM的根元素 - 换句话说，这允许你从其shadow DOM中选择一个自定义元素</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpvbmx5LWNoaWxk">:only-child<i class="fa fa-external-link-alt"></i></span></td>
<td>匹配没有任何兄弟元素的元素（只有1个元素）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzphbnktbGluaw==">:any-link<i class="fa fa-external-link-alt"></i></span></td>
<td>代表一个有链接锚点的元素，而不管它是否被访问过，也就是说，它会匹配每一个有 <code>href</code> 属性的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a" target="_blank" rel="noopener"><code>&lt;a&gt;</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/area" target="_blank" rel="noopener"><code>&lt;area&gt;</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link" target="_blank" rel="noopener"><code>&lt;link&gt;</code></a> 元素。因此，它会匹配到所有的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:link" target="_blank" rel="noopener"><code>:link</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:visited" target="_blank" rel="noopener"><code>:visited</code></a>。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpob3N0KCk=">:host()<i class="fa fa-external-link-alt"></i></span></td>
<td>选择包含使用这段 CSS 的 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvV2ViX0NvbXBvbmVudHMvVXNpbmdfc2hhZG93X0RPTQ==">Shadow DOM<i class="fa fa-external-link-alt"></i></span> 的影子宿主（这样就可以从 Shadow DOM 中选择包括它的自定义元素）—— 但前提是该函数的参数与选择的阴影宿主相匹配。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>最简单的用法是仅将类名放在某些自定义元素实例上，然后将相关的类选择器作为函数参数包含在内。不能将它与后代选择器表达式一起使用，以仅选择特定祖先内部的自定义元素的实例。这是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:host-context()" target="_blank" rel="noopener"><code>:host-context()</code></a> 的作用。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpvbmx5LW9mLXR5cGU=">:only-of-type<i class="fa fa-external-link-alt"></i></span></td>
<td><code>:only-of-type</code> 代表了任意一个元素，这个元素没有其他相同类型的兄弟元素。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzotbW96LW9ubHktd2hpdGVzcGFjZQ==">:blank<i class="fa fa-external-link-alt"></i></span></td>
<td>匹配没有子节点、仅有空的文本节点、仅有空白符的文本节点的节点</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpvcHRpb25hbA==">:optional<i class="fa fa-external-link-alt"></i></span></td>
<td>表示没有required 属性的 input select 或者 textarea</td>
<td></td>
<td></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9qc2Jpbi5jb20vbGVsZWR1bGlkby9lZGl0P2h0bWwsY3NzLG91dHB1dA==">demo<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpjaGVja2Vk">:checked<i class="fa fa-external-link-alt"></i></span></td>
<td>表示任何处于选中状态的<strong>radio</strong>(<code>&lt;input type=&quot;radio&quot;&gt;</code>), <strong>checkbox **(<code>&lt;input type=&quot;checkbox&quot;&gt;</code>) 或(“select”) 元素中的</strong>option **HTML元素(“option”)。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpob3Zlcg==">:hover<i class="fa fa-external-link-alt"></i></span></td>
<td>用户移动到一个元素上（还未激活）；触摸屏上 hover 基本不可用，不同的浏览器上表现不同；</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpvdXQtb2YtcmFuZ2U=">:out-of-range<i class="fa fa-external-link-alt"></i></span></td>
<td>表示一个input元素，当值处于属性min和max限定的范围之外; <strong>只适用于拥有范围设定的元素；type = number、range、date、datetime、datetime-local、month、time、week；</strong></td>
<td></td>
<td></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9qc2Jpbi5jb20vbWVwb2ZhcWF2YS9lZGl0P2h0bWwsY3NzLG91dHB1dA==">demo<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>:in-range</td>
<td>同上，只不过刚好相反</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzppbmRldGVybWluYXRl">:indeterminate<i class="fa fa-external-link-alt"></i></span></td>
<td>表示状态不确定的表单元素；如表单元素的indeterminate属性值被设置为true；radio中具有相同name值的所有单选按钮都未被选中；处于不确定状态的progress；</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpkZWZhdWx0">:default<i class="fa fa-external-link-alt"></i></span></td>
<td>表示一组相关元素中的默认表单元素</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpkZWZpbmVk">:defined<i class="fa fa-external-link-alt"></i></span></td>
<td>表示任何已定义的元素。这包括任何浏览器内置的标准元素以及已成功定义的自定义元素，shadow DOM</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzppbnZhbGlk">:invalid<i class="fa fa-external-link-alt"></i></span></td>
<td>表示任意内容未通过验证的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input" target="_blank" rel="noopener"><code>&lt;input&gt;</code></a> 或其他 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form" target="_blank" rel="noopener"><code>&lt;form&gt;</code></a> 元素 .</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpyZWFkLW9ubHk=">:read-only<i class="fa fa-external-link-alt"></i></span></td>
<td>表示元素不可被用户编辑的状态（如锁定的文本输入框）；注意：该选择器会选择作用域下所有的用户只读的内容，如p、div、span</td>
<td></td>
<td></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9qc2Jpbi5jb20vZWRpdD9odG1sLGNzcyxvdXRwdXQ=">demo<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpyZWFkLXdyaXRl">:read-write<i class="fa fa-external-link-alt"></i></span></td>
<td>同上，只不过用户可以编辑；</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpkaXNhYmxlZA==">:disabled<i class="fa fa-external-link-alt"></i></span></td>
<td>表示任何被禁用的元素；如果一个元素不能被激活（选择、点击、接受文本输入、获取焦点），则该元素处于禁用状态；对于pointer-events:none 的元素不生效；</td>
<td></td>
<td></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9qc2Jpbi5jb20vZ2V3b2d1cmViaS9lZGl0P2h0bWwsY3NzLG91dHB1dA==">demo<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpsYW5n">:lang<i class="fa fa-external-link-alt"></i></span></td>
<td>基于元素语言来匹配页面元素</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpyZXF1aXJlZA==">:required<i class="fa fa-external-link-alt"></i></span></td>
<td>表示拥有required的表单元素</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpsYXN0LWNoaWxk">:last-child<i class="fa fa-external-link-alt"></i></span></td>
<td>表示作用域下的最后一个子元素</td>
<td></td>
<td></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9qc2Jpbi5jb20vam9kYW5vZmVwZS9lZGl0P2h0bWwsY3NzLG91dHB1dA==">demo<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzplbXB0eQ==">:empty<i class="fa fa-external-link-alt"></i></span></td>
<td>代表没有子元素的元素。子元素只可以是元素节点或文本（包括空格）。注释或处理指令都不会产生影响。简单来讲，只要元素中<strong>包含了空格、非注释节点</strong>，就无法匹配上（<strong>不含伪元素，只有伪元素也能匹配</strong>）</td>
<td></td>
<td></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9qc2Jpbi5jb20vYmF0ZWNlemFrby8zL2VkaXQ/aHRtbCxjc3Msb3V0cHV0">demo<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpsYXN0LW9mLXR5cGU=">:last-of-type<i class="fa fa-external-link-alt"></i></span></td>
<td>表示作用域下给定类型的最后一个元素</td>
<td></td>
<td></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9qc2Jpbi5jb20vcXVqb2dvaml5aS9lZGl0P2h0bWwsY3NzLG91dHB1dA==">demo<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpyb290">:root<i class="fa fa-external-link-alt"></i></span></td>
<td>匹配文档元素的根元素，对于HTML来说， :root 就表示html，只不过优先级更高（相比于html）；实际上，html[lang=””] 来选择的话，优先级就高于:root了；</td>
<td></td>
<td></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9qc2Jpbi5jb20veW94dWpvY2liby8xL2VkaXQ/aHRtbCxjc3Msb3V0cHV0">demo<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzplbmFibGVk">:enabled<i class="fa fa-external-link-alt"></i></span></td>
<td>对比上面的:disabled</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpzY29wZQ==">:scope<i class="fa fa-external-link-alt"></i></span></td>
<td>一般在js中使用，用于选择元素本身，如querySelectorAll(‘:scope &gt; div’)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzp0YXJnZXQ=">:target<i class="fa fa-external-link-alt"></i></span></td>
<td>代表唯一的一个页面元素，其id与当前URL片段匹配；配合锚点可以做很多有趣的事情，参见示例</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpmaXJzdC1jaGlsZA==">:first-child<i class="fa fa-external-link-alt"></i></span></td>
<td>一组兄弟元素中的第一个元素</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpmaXJzdC1vZi10eXBl">:fist-of-type<i class="fa fa-external-link-alt"></i></span></td>
<td>一组兄弟元素中其类型的第一个元素</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpub3Q=">:not<i class="fa fa-external-link-alt"></i></span></td>
<td>用来匹配不符合一组选择器的元素。由于它的作用是防止特定的元素被选中，它也被称为_反选伪类<em>（</em>negation pseudo-class_）。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpudGgtY2hpbGQ=">:nth-child(an+b)<i class="fa fa-external-link-alt"></i></span></td>
<td>从1开始排序，匹配 an + b（n = 0, 1, 2, 3, 4） 的元素；可以选择odd/even(偶数)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzp2YWxpZA==">:valid<i class="fa fa-external-link-alt"></i></span></td>
<td>参考:invalid</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpmb2N1cw==">:focus<i class="fa fa-external-link-alt"></i></span></td>
<td>获得焦点的元素，仅适用于焦点元素本身</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpudGgtbGFzdC1jaGlsZA==">:nth-last-child()<i class="fa fa-external-link-alt"></i></span></td>
<td>从兄弟节点从后往前匹配</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpmb2N1cy13aXRoaW4=">:focus-within<i class="fa fa-external-link-alt"></i></span></td>
<td>表示一个元素获得焦点或者一个元素的后代元素获得焦点</td>
<td></td>
<td></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9qc2Jpbi5jb20vcWlwb2NpcHVoYS9lZGl0P2h0bWwsY3NzLG91dHB1dA==">demo<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpudGgtbGFzdC1vZi10eXBl">:nth-last-of-type<i class="fa fa-external-link-alt"></i></span></td>
<td>从结尾处开始计数</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpudGgtb2YtdHlwZQ==">:nth-of-type<i class="fa fa-external-link-alt"></i></span></td>
<td>针对具有一组兄弟节点的标签, 用 n 来筛选出在一组兄弟节点的位置。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><a name="l3DPA"></a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>链接的几种状态处理（:link、:visited、:hover、:active）</li>
</ul>
<p>由于这几种状态可能会被后续声明的规则覆盖，因此为保证样式生效，需要协调好优先级，其设置顺序称之为LVHA顺序 —— <code>:link</code> — <code>:visited</code> — <code>:hover</code> — <code>:active</code></p>
<ul>
<li><strong>元素的选中</strong></li>
</ul>
<p>如果 <code>&lt;selector&gt;:pseudo-class</code> 选中的是 <code>&lt;selector&gt;</code> 本身， <code>&lt;selector&gt; :pseudo-class</code> 才       会选中后代元素，参见<span class="exturl" data-url="aHR0cHM6Ly9qc2Jpbi5jb20vcGViZXJlZm9zdS8xL2VkaXQ/aHRtbCxjc3Msb3V0cHV0">demo<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>文本打印<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpsZWZ0">left<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpyaWdodA==">right<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTLzpmaXJzdA==">first<i class="fa fa-external-link-alt"></i></span> - 打印文档的时候，第一页的样式</li>
<li></li>
</ul>
</li>
</ul>
<p><a name="zgfUF"></a></p>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a><span class="exturl" data-url="aHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3NlbGVjdG9ycy0zLyNwc2V1ZG8tZWxlbWVudHM=">伪元素<i class="fa fa-external-link-alt"></i></span></h2><p><a name="K11G0"></a></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>伪元素（pseudo-element）是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。</p>
<blockquote>
<p>Pseudo-elements create abstractions about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content. Pseudo-elements allow authors to refer to this otherwise inaccessible information. Pseudo-elements may also provide authors a way to refer to content that does not exist in the source document (e.g., the <a href="https://drafts.csswg.org/selectors-3/#sel-before" target="_blank" rel="noopener"><code>::before</code></a> and <a href="https://drafts.csswg.org/selectors-3/#sel-after" target="_blank" rel="noopener"><code>::after</code></a> pseudo-elements give access to generated content).<br>A pseudo-element is made of two colons (<code>::</code>) followed by the name of the pseudo-element.</p>
</blockquote>
<blockquote>
<p>This <code>::</code> notation is introduced by the current document in order to establish a discrimination between pseudo-classes and pseudo-elements. For compatibility with existing style sheets, user agents must also accept the previous one-colon notation for pseudo-elements introduced in CSS levels 1 and 2 (namely, <a href="https://drafts.csswg.org/selectors-3/#sel-first-line" target="_blank" rel="noopener"><code>:first-line</code></a>, <a href="https://drafts.csswg.org/selectors-3/#first-letter0" target="_blank" rel="noopener"><code>:first-letter</code></a>, <a href="https://drafts.csswg.org/selectors-3/#sel-before" target="_blank" rel="noopener"><code>:before</code></a> and <a href="https://drafts.csswg.org/selectors-3/#sel-after" target="_blank" rel="noopener"><code>:after</code></a>). This compatibility is not allowed for the new pseudo-elements introduced in this specification.</p>
</blockquote>
<blockquote>
<p>Only one pseudo-element may appear per selector, and if present it must appear after the sequence of simple selectors that represents the <span class="exturl" data-url="aHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3NlbGVjdG9ycy0zLyNzdWJqZWN0">subjects<i class="fa fa-external-link-alt"></i></span> of the selector. </p>
</blockquote>
<p><a name="vFkWg"></a></p>
<h3 id="类别-1"><a href="#类别-1" class="headerlink" title="类别"></a>类别</h3><table>
<thead>
<tr>
<th>伪类</th>
<th>含义</th>
<th></th>
<th></th>
<th>demo</th>
</tr>
</thead>
<tbody><tr>
<td>::after</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>::before</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>::first-line</td>
<td>first-line 不会匹配任何真实的DOM元素，只会匹配由用户代理插入的元素（该行为不可见，用户代理会自动插入相应的虚拟标签）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><img align=left height=142 width=567 data-src="https://cdn.nlark.com/yuque/0/2020/png/434020/1586917127588-4a5da5d6-265b-4d43-ae71-6bb64e30efbe.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>需要注意的是，该选择器只对默认block的元素生效。默认行内的元素，即使设置了该属性，也不会生效。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>::first-letter</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>::selection</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><a name="JJCBD"></a></p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p><a name="aOpki"></a></p>
<h2 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h2><p>区别在于最后是否产生一个真实的DOM节点（这个节点可能对用户可见， 如::before、::after，也有可能对用户不可见，如::first-letter、::first-line），如::first-letter虽然对DOM  不可见，但是用户代理实际上是对满足条件的元素增加了一个虚拟标签</p>
<p>参考：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3NlbGVjdG9ycy0zLw==">CSS 3 规范<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <tags>
        <tag>每天学习一丢丢~</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的双重转义</title>
    <url>/2016/07/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8F%8C%E9%87%8D%E8%BD%AC%E4%B9%89/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>习惯了<code>SPA</code>的开发模式， 现在随便弄点什么东西， 渲染<code>HTML</code>什么的也总是通过<code>JS</code>来了， 但是在<code>JS</code>里写<code>HTML</code>总归是影响代码美观的， 虽然有现成的模板工具可以使用， 但是这人一旦任性起来是真的拉都拉不住。 某日闲得飞起， 就准备写这么一个小东西。</p>
<a id="more"></a>

<p>思路是这样的， 在一个目录下专门存放<code>html</code>, 然后通过<code>Nodejs</code>来读取<code>html</code>, 之后根据文件名和文件内容生成一个对象，如下所示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  test: <span class="string">'&lt;div&gt;div1&lt;/div&gt;'</span>,</span><br><span class="line">  test2: <span class="string">'&lt;div&gt;div2&lt;/div&gt;'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后使用<code>JSON.stringify()</code>将这个对象转化为字符串， 存储为一个<code>JS</code>文件， 当然， 同时还会声明一个变量啊啥的， 大概就下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设得到的字符串是`&#123;"test":"&lt;div&gt;div1&lt;/div&gt;"&#125;`  那么这个存储字符串的文件内容大概就是这样</span></span><br><span class="line"><span class="keyword">const</span> template = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"test":"&lt;div&gt;div1&lt;/div&gt;"&#125;'</span>);</span><br></pre></td></tr></table></figure>
<p>之后在<code>html</code>里面引入这个<code>JS</code>, 然后就可以通过<code>template.test</code>来访问对应的<code>html</code>内的东西了。</p>
<p>样子大概就是这个样子。然而人生不如意之事十之八九， 这句话放在码代码身上也不例外。也许还得改一改， 人生不如意之事100%！！！</p>
<p>上面的<code>html</code>还是比较简单的， 然而谁会像我一样闲的蛋疼专门建一个<code>html</code>文件就为了放一个<code>div</code>.</p>
<p>稍微来个复杂的， 假如一个叫<code>test2</code>的<code>html</code>内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后最后生成的文件内容是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> template = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"test":"&lt;div class=\"container\"&gt;\r\n  &lt;div class=\"left\"&gt;&lt;/div&gt;\r\n  &lt;div class=\"right\"&gt;&lt;/div&gt;\r\n&lt;/div&gt;\r\n"&#125;'</span>);</span><br></pre></td></tr></table></figure>

<p>耶， 真棒， 看起来好像没什么问题， 人家都还给转义了， 然后放到浏览器里一跑</p>
<p><img data-src="http://o9ts2tlvd.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160705130109.png" alt=""></p>
<p>看看错误详情</p>
<p><img data-src="http://o9ts2tlvd.bkt.clouddn.com/%E9%94%99%E8%AF%AF%E8%AF%A6%E6%83%85.png" alt=""></p>
<p>在错误详情里面可以明显地看到被引号引起来的<code>container</code>和其他周围的字符串颜色并不一样， 但是明明字符串里就加了转义字符的呀。</p>
<h2 id="症结"><a href="#症结" class="headerlink" title="症结"></a>症结</h2><p>先说说转义字符的意思吧（我瞎蒙的， 说错了别打我）。</p>
<p>比如<code>&quot;\&quot;&quot;</code>放到浏览器里运行的话， 得到的结果是<code>&quot;&quot;&quot;</code>。这里的斜杠就对中间的那个双引号进行了转义， 告诉浏览器这个东西表示的只是一个引号，你别解析错了， 因此得到的就是三个引号。所以在这里， 当浏览器把一个字面量转变为字符串的时候， 转义了一次， 吞了一次转义字符。</p>
<p>如下图所示， 可以看到字符串字面量里面本来是有斜线的， 但是赋值给变量之后那斜线就被吃了。</p>
<p><img data-src="http://o9ts2tlvd.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160705131425.png" alt=""></p>
<p>然后在进行<code>JSON.parse()</code>的时候， 无奈地碰到了双引号， 然后就悲剧地报错了。</p>
<p>所以在对字符串进行转换， 转变为一个对象的时候依然需要进行转义， 前面提到过， 使用<code>\</code>进行转义， 但是<code>\</code>除了表示字符<code>\</code>之外， 也表示转义字符， 所以这里还需要对’&#39;进行转义， 也就是进行双转义。</p>
<p>举个例子， 比如判断某个元素具不具有某个类名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasClass</span> (<span class="params">sourceCls, cls</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span> + cls + <span class="string">'\\b'</span>, <span class="string">'g'</span>).test(sourceCls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是先对<code>\</code>进行了转义，因此出现了两个<code>\</code>。</p>
<p>所以简单的来说。。。双转义就是<code>&#39;\&#39; * 2</code>, 原本应该是一个的就上俩， 是两个的就上四个。</p>
<p>然后负责读取文件生成数据的<code>JS</code>就成了这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">fs.readFile(<span class="string">'./test.html'</span>, (_, data) =&gt; &#123;</span><br><span class="line">  obj.test = data.toString();</span><br><span class="line">  fs.writeFile(<span class="string">'./testJSON.js'</span>, <span class="string">'const template = JSON.parse(\''</span> + getStr(obj) + <span class="string">'\');'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStr</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过JSON.stringify序列化后的加了转义符号的字符串大概就是\"这个样子</span></span><br><span class="line">  <span class="comment">// 所以这里的两根斜杠前者只是对后者的转义而已</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data).replace(<span class="regexp">/\\/g</span>, <span class="string">'\\\\'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然， 上面那种方式比较简单粗暴， 只是为了说明一下怎么解决这个问题而已。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就我自己的理解来的话， 需要双转义的地方一般是进行了两次解析的， <code>字面量 =&gt; 字符串 =&gt; ..</code>, 这里的<code>..</code>可能是正则表达式， 也可能是其他的啥啥啥。。。</p>
<p>最后， 感谢<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3UvYXJpc3RvdGxs">aristotll<i class="fa fa-external-link-alt"></i></span>对我问题的回答。</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>对象URL</title>
    <url>/2019/12/21/%E5%AF%B9%E8%B1%A1URL/</url>
    <content><![CDATA[<p>学习地址：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1VSTA==">https://developer.mozilla.org/zh-CN/docs/Web/API/URL<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a> 
<p>实例代码地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzM3NDYzMjg5Ny9kZW1vcy9ibG9iL21hc3Rlci9odG1sL29iamVjdC11cmwvY29tcGFyZS5odG1s">GitHub<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvLzM3NDYzMjg5Ny9wZW4vUndOcFhQZD9lZGl0b3JzPTExMTE=">CodePen<i class="fa fa-external-link-alt"></i></span></p>
<p>URL 为 window 的一个属性， 具有三种用法：</p>
<ul>
<li>URL 作为构造函数使用 - new URL(url, [base])</li>
<li>URL.createObjectURL(blob)</li>
<li>URL.revokeObjectURL(objectURL)</li>
</ul>
<p><a name="1H2Qi"></a></p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>作为构造器使用时，可接收两个参数，第一个参数为url，如果url为绝对路径，则第二个参数会被忽略；如果url为相对路径，则需要第二个参数，若缺少第二个参数，那么会报错Invalid URL。<br><img align=left height=244 width=666 data-src="https://cdn.nlark.com/yuque/0/2019/png/434020/1576918708879-8233bb2f-a0ed-4971-91c5-14601026c194.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /></p>
<p>如果要获取 query 值，可以通过url.searchParams.get来获取<br><img align=left height=38 width=217 data-src="https://cdn.nlark.com/yuque/0/2019/png/434020/1576918754116-0d34cee7-5cca-4d8c-a5fb-0f8220577ee6.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /></p>
<p>其兼容性如下所示：<br><img align=left height=403 width=1045 data-src="https://cdn.nlark.com/yuque/0/2019/png/434020/1576918817459-618f459b-c4cf-4206-835b-11f99b5ec447.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /><br>可以看到， IE 系列的浏览器是不支持该属性的。</p>
<p><a name="00O9z"></a></p>
<h3 id="URL-createObjectURL-blob"><a href="#URL-createObjectURL-blob" class="headerlink" title="URL.createObjectURL(blob)"></a>URL.createObjectURL(blob)</h3><p>通常来讲， 需要使用本方法的时候是手动在前端进行了文件上传，并且希望及时的进行预览。除了本方法之外，在用户选择文件之后，可以通过FileReader对文件进行阅读， 使用readAsDataURL的方式，将文件内容转换为base64的形式，并将其作为img 的 src 以进行展示。然而该方法具有以下问题：</p>
<ul>
<li>需要先使用FileReader对文件进行读取到JavaScript中，当文件内容比较大的时候，中间的时间难以保证（参见<span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvLzM3NDYzMjg5Ny9wZW4vUndOcFhQZD9lZGl0b3JzPTExMTE=">DEMO<i class="fa fa-external-link-alt"></i></span>，针对4M的文件， base64比object url 慢了10倍左右 )</li>
<li>生成的base64字符串可能会十分庞大，插入到DOM以后会多了很多无意义的内容</li>
<li>使用 base64 会占用对应的堆空间（参见<span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvLzM3NDYzMjg5Ny9wZW4vUndOcFhQZD9lZGl0b3JzPTExMTE=">DEMO<i class="fa fa-external-link-alt"></i></span>）</li>
</ul>
<p>因此，针对需要在前端进行展示的场景，应尽可能地使用URL.createObjectURL()的方式来进行展示，而不是使用base64。通过该方式，最后获取到的是一个指向内存的相应地址，因为该字符串是一个URL，因此可以直接在DOM中使用，同时，也不用先将文件读取到JavaScript中。</p>
<p>兼容性如下：<br><img align=left height=413 width=1031 data-src="https://cdn.nlark.com/yuque/0/2019/png/434020/1576922437474-6d9e345f-cce9-4f8f-b93d-7c49717d55fc.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /><br>可以看到，IE10以上的浏览器均兼容。</p>
<p><a name="vCnoF"></a></p>
<h3 id="URL-revokeObjectURL"><a href="#URL-revokeObjectURL" class="headerlink" title="URL.revokeObjectURL()"></a>URL.revokeObjectURL()</h3><p><strong><code>URL.revokeObjectURL()</code> **静态方法用来释放一个之前已经存在的、通过调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL" target="_blank" rel="noopener"><code>URL.createObjectURL()</code></a> 创建的 URL 对象。当你结束使用某个 URL 对象之后，应该通过调用这个方法来让浏览器知道</strong>不用在内存中继续保留对这个文件的引用了**。<br>你可以在 <code>sourceopen</code> 被处理之后的任何时候调用 <code>revokeObjectURL()</code>。这是因为 <code>createObjectURL()</code> 仅仅意味着将一个媒体元素的 <code>src</code> 属性关联到一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource" target="_blank" rel="noopener"><code>MediaSource</code></a> 对象上去。调用<code>revokeObjectURL()</code> 使这个潜在的对象回到原来的地方，允许平台在合适的时机进行垃圾收集。</p>
]]></content>
      <tags>
        <tag>每天学习一丢丢~</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2016/06/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="RegExp学习总结"><a href="#RegExp学习总结" class="headerlink" title="RegExp学习总结"></a>RegExp学习总结</h1><a id="more"></a>

<h2 id="字符集合（Character-Sets）"><a href="#字符集合（Character-Sets）" class="headerlink" title="字符集合（Character Sets）"></a>字符集合（Character Sets）</h2><ul>
<li>[xyz] 字符组|字符集合， 匹配集合中的任意一个字符， 可以使用连字符’-‘来指定一个范围。 如<code>[abcd]</code>可以表示为<code>[a-d]</code>。</li>
<li>[^xyz] 反义字符组， 匹配中括号中不存在的内容</li>
</ul>
<h2 id="字符边界-Boundaries"><a href="#字符边界-Boundaries" class="headerlink" title="字符边界 (Boundaries)"></a>字符边界 (Boundaries)</h2><ul>
<li><p>^  匹配字符串开头</p>
</li>
<li><p>$  匹配字符串结尾</p>
</li>
<li><p>\b 匹配一个零宽单词边界 如一个字母和一个空格之间， 一个字符串的开头和结尾</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'et'</span>.match(<span class="regexp">/\bet/</span>); <span class="comment">// ["et"]</span></span><br><span class="line"><span class="string">'testfsad'</span>.match(<span class="regexp">/\bet/</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li>
<li><p>\B 匹配一个零宽非单词边界， 如两个字母之间或两个空格之间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'   '</span>.match(<span class="regexp">/\B/</span>); <span class="comment">// four white-spaces</span></span><br><span class="line"><span class="comment">// ["", "", "", ""];</span></span><br></pre></td></tr></table></figure>
<h2 id="分组-Grouping-和-反向引用-back-references"><a href="#分组-Grouping-和-反向引用-back-references" class="headerlink" title="分组(Grouping) 和 反向引用(back references)"></a>分组(Grouping) 和 反向引用(back references)</h2></li>
<li><p><code>(x)</code>  </p>
<p>匹配x并且捕获匹配项。 捕获组(Capturing groups)有性能惩罚， 再次访问被捕获的子字符串最好使用非捕获符号</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Yes, I wanna earn more money'</span>;</span><br><span class="line">/(\S)*\s/.test(str); </span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span> <span class="comment">// ","</span></span><br><span class="line"></span><br><span class="line">/(\S*)\s/.test(str);</span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span> <span class="comment">// '"Yes,"</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>\n</code><br>n是一个正整数。 指向正则表达式中第n个括号（从左边开始数）中匹配的字符串 <strong>这里有点问题</strong></p>
</li>
<li><p><code>(?:x)</code><br>匹配x不会捕获匹配项， 非匹配项不能通过RegExp的$1-$9属性访问到。 </p>
<h2 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h2></li>
<li><p><code>x*</code><br>匹配前面的模式x 0次或多次</p>
</li>
<li><p><code>x+</code><br>匹配前面的模式x 1次或多次， 等价于{1,}</p>
</li>
<li><p><code>x*?</code>, <code>x+?</code><br>匹配前面的模式， 但是是执行最小可能匹配</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Yes, I wanna earn more money"</span>;</span><br><span class="line">str.match(<span class="regexp">/\w*?/</span>); <span class="comment">// [""]    // 最小匹配模式， 可匹配0次</span></span><br><span class="line">str.match(<span class="regexp">/\w*/</span>);  <span class="comment">// ["Yes"]  </span></span><br><span class="line"></span><br><span class="line">str.match(<span class="regexp">/\w+/</span>);  <span class="comment">// ["Yes"]</span></span><br><span class="line">str.match(<span class="regexp">/\w+?/</span>); <span class="comment">// ["Y"]   // 最小匹配模式， 只匹配1次</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>x?</code><br>匹配前面的模式x 0次或1次 。 如果在数量词<code>*</code>, <code>+</code>, <code>?</code>或者<code>{}</code>任意一个后面添加该符号（?）, 将会使匹配模式变为非贪婪模式(non-greedy)， 即匹配次数最小化， 默认匹配模式是贪婪模式， 即匹配次数最大化。 </p>
</li>
<li><p><code>x(?=y)</code> 只有当x后面紧跟着y的时候才会进行匹配， 但是y不会成为匹配内容的一部分  . 注意要加括号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> str = <span class="string">'hello world, I feel so good today'</span>;</span><br><span class="line">  str.match(<span class="regexp">/feel(?= so)/</span>); <span class="comment">// ["feel"]</span></span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* `</span>x(?!y)<span class="string">`</span></span><br><span class="line"><span class="string">  只有当x后面不是紧跟着y的时候才会进行匹配</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>js</span><br><span class="line">  str.match(<span class="regexp">/feel(?!so)/</span>); <span class="comment">// ["feel"] // 注意： 中间没有空格</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>x|y</code><br>匹配x或者y  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.match(<span class="regexp">/hello|world/</span>);         <span class="comment">// ["hello"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时匹配的是[]内的每一个可能值， 只匹配1次的话就匹配到了'h'， 而此时'|'也只被当成一个普通的字符</span></span><br><span class="line">str.match(<span class="regexp">/[hello|world]/</span>);       <span class="comment">// ["h"] </span></span><br><span class="line"><span class="string">'jfsdalk|sajd'</span>.match(<span class="regexp">/[fa|fj]/g</span>); <span class="comment">// ["j", "f", "a", "|", "a", "j"]</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>x{n}</code><br>n是一个正整数， 前面的模式连续出现n次时匹配</p>
</li>
<li><p><code>x{n,}</code></p>
</li>
<li><p><code>x{n,y}</code><br> <strong>Note:</strong> 这里n和y之间不能有空格  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从url中提取子域名</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"http://xxx.domain.com"</span>;</span><br><span class="line">url.replace(<span class="regexp">/https?:\/\/([^.]*)\..*/</span>, <span class="string">'$1'</span>); <span class="comment">// "xxx"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>参见  <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhw">MDN – 正则表达式<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
  </entry>
  <entry>
    <title>基于git diff的eslint代码检测</title>
    <url>/2016/08/15/%E5%9F%BA%E4%BA%8Egit-diff%E7%9A%84eslint%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="基于git-diff进行的eslint代码检测"><a href="#基于git-diff进行的eslint代码检测" class="headerlink" title="基于git diff进行的eslint代码检测"></a>基于git diff进行的eslint代码检测</h1><p>随着代码的不断增加， eslint进行代码检测的时间也越来越久。每次检测的时候， 需要检测的文件和实际检测的文件极度不对称，所以便基于<code>git diff</code>写了这样一个小工具。</p>
<a id="more"></a>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><ul>
<li>启动脚本(<code>lint.sh</code>)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">INFO=<span class="string">'\033[36m'</span>;</span><br><span class="line">NOR=<span class="string">'\033[0m'</span>;</span><br><span class="line">ERR=<span class="string">'\033[31m'</span>;</span><br><span class="line">br=<span class="string">'dev'</span>;</span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="variable">$1</span> ]; <span class="keyword">then</span></span><br><span class="line">  br=<span class="variable">$1</span>;</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;INFO&#125;</span>run lint now ... just wait a moment ...<span class="variable">$&#123;NOR&#125;</span>"</span>;</span><br><span class="line">git diff origin/<span class="variable">$&#123;br&#125;</span> &gt; diff.log;</span><br><span class="line"><span class="built_in">log</span>=`cat diff.log | grep <span class="string">'diff --git a/src'</span>`;</span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="variable">$&#123;log&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;INFO&#125;</span>没有文件发生变化<span class="variable">$&#123;NOR&#125;</span>"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">echo</span> <span class="string">''</span>;</span><br><span class="line">  node ./lint-by-diff.js;</span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;INFO&#125;</span>done ...<span class="variable">$&#123;NOR&#125;</span>"</span>;</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line">rm diff.log change.log 2&gt; /dev/null;</span><br><span class="line"><span class="built_in">read</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>检测工具(<code>lint-by-diff.js</code>)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> shelljs = <span class="built_in">require</span>(<span class="string">'shelljs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsFiles = [],</span><br><span class="line">  LOG__PATH   = <span class="string">'./diff.log'</span>,</span><br><span class="line">  FILE = <span class="regexp">/diff --git a([\s\S]*?) /g</span>,</span><br><span class="line">  data = fs.readFileSync(LOG__PATH).toString(),</span><br><span class="line">  _files = data.match(FILE),</span><br><span class="line">  len = _files.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">  <span class="keyword">const</span> _item = _files[i++].trim();</span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/.js$/</span>.test(_item)) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">const</span> item = <span class="string">'./'</span> + _item.slice(<span class="number">13</span>);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/^\.\/src\//</span>.test(item)) <span class="keyword">continue</span>; <span class="comment">// src为项目需要进行eslint检测的目录</span></span><br><span class="line">  <span class="keyword">if</span> (!fs.existsSync(item)) <span class="keyword">continue</span>;</span><br><span class="line">  jsFiles.push(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------------------------------'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'     以下文件发生改变： '</span>);</span><br><span class="line"><span class="built_in">console</span>.log(jsFiles.join(<span class="string">'\n'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------------------------------'</span>);</span><br><span class="line">shelljs.exec(<span class="string">'node ./node_modules/eslint/bin/eslint.js '</span> + jsFiles.join(<span class="string">' '</span>));</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过<code>git diff origin/branch</code>获取到和指定分支的不同， 从而知道哪些文件需要进行代码检测（dev上的是通过检测的）， 然后运行eslint的时候就指定这部分文件。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在项目根目录下输入<code>./lint.sh</code>或者<code>bash ./lint.sh</code>, 默认分支为<code>dev</code>分支， 如果需要指定其他分支， 可以在运行的时候传入参数， 如： <code>bash ./lint.sh master</code>.</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul>
<li><p>使用了bash导致这个看起来有点不伦不类， 使用纯js也许会更好， 但是我毕竟半吊子， 写不出来→＿←</p>
</li>
<li><p>没有对<code>error</code>进行高亮显示， 所以看起来会比较费力</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>用来放一些tips中的DEMO</title>
    <url>/2016/05/10/%E7%94%A8%E6%9D%A5%E6%94%BE%E4%B8%80%E4%BA%9Btips%E4%B8%AD%E7%9A%84DEMO/</url>
    <content><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ul>
<li><span class="exturl" data-url="aHR0cDovLzM3NDYzMjg5Ny5naXRodWIuaW8vanVzdC1zb21lLXRpcHMvREVNTy/mtYvor5XmmL7npLrpmpDol4/nmoTkuKTnp43lrp7njrDmlrnlvI/nmoTmgKfog70uaHRtbA==">测试显示隐藏的两种实现方式的性能<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="CSS-amp-HTML"><a href="#CSS-amp-HTML" class="headerlink" title="CSS &amp; HTML"></a>CSS &amp; HTML</h2><ul>
<li><span class="exturl" data-url="aHR0cDovLzM3NDYzMjg5Ny5naXRodWIuaW8vcmdybXMv">仿制的第一个站（前东家官网）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovLzM3NDYzMjg5Ny5naXRodWIuaW8vanVzdC1zb21lLXRpcHMvREVNTy90ZXN0R3JhZGludC5odG1s">实现慕课网官网楼层动态效果<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovLzM3NDYzMjg5Ny5naXRodWIuaW8vanVzdC1zb21lLXRpcHMvREVNTy9pbmRleDEyMy5odG1s">对指定文字设置样式<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovLzM3NDYzMjg5Ny5naXRodWIuaW8vanVzdC1zb21lLXRpcHMvREVNTy9kcmF3QUVnZy5odG1s">画个鸡蛋吧<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovLzM3NDYzMjg5Ny5naXRodWIuaW8vanVzdC1zb21lLXRpcHMvc3JjL2dhbWVzL2NvbG9yLmh0bWw=">颜色块儿<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovLzM3NDYzMjg5Ny5naXRodWIuaW8vanVzdC1zb21lLXRpcHMvc3JjL2dhbWVzL2JvbnVzLmh0bWw=">点个转盘<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovLzM3NDYzMjg5Ny5naXRodWIuaW8vanVzdC1zb21lLXRpcHMvc3JjL2xheW91dC8zQ29sdW1ucy5odG1s">3列布局， 左右定宽，中间自适应<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovLzM3NDYzMjg5Ny5naXRodWIuaW8vanVzdC1zb21lLXRpcHMvc3JjL3JpY2hUZXh0RWRpdG9yLmh0bWw=">一个简单的富文本编辑器<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovLzM3NDYzMjg5Ny5naXRodWIuaW8vanVzdC1zb21lLXRpcHMvc3JjL2h0bWw1QVBJcy9GdWxsU2NyZWVuLmh0bWw=">全屏<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovLzM3NDYzMjg5Ny5naXRodWIuaW8vanVzdC1zb21lLXRpcHMvc3JjL+a1i+ivleWxheS4rS5odG1s">居中<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="http://noteawesome.com/just-some-tips/src/keyCode.html">键码</a></li>
<li><a href="http://noteawesome.com/algorithms/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%8E%92%E5%BA%8F/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html">算法学习</a></li>
</ul>
]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>我的时间都去哪儿了</title>
    <url>/2016/05/17/%E6%88%91%E7%9A%84%E6%97%B6%E9%97%B4%E9%83%BD%E5%8E%BB%E5%93%AA%E5%84%BF%E4%BA%86/</url>
    <content><![CDATA[<p>前段时间把网给停了， 理由是在有网的情况下， 我每天在回到家后都把为数不多的时间浪费在上网上面去了， 虽然能有所收获，但是总体而言是弊大于利的， 毕竟大部分的时间里我都是在做着一些无关紧要的事情。所以我把网停了， 希望能够借助这种手段来强迫自己不断地学习新的东西。 效果是有的， 然而我依然对自己不是很满意。</p>
<a id="more"></a>

<p>不得不承认， 我是一个自我控制能力很弱的人。 我很容易分心， 很容易感到枯燥。所以采用这样的方法来让自己被动地学习。然而即使这样做了， 却依旧没有达到我想要的效果。 在我的想象中， 每天下班之后， 或者在周末的时候， 我除了买菜做饭和正常的休息时间之外， 其他的时间应该都用来看书， 或者码代码， 毕竟这样才能快速地提高自己。相比于刚刚接触JS（去年9月份的时候）的那段时间， 自己现在真的是弱爆了。 那段时间是我真正的有状态的阶段，连吃饭的时候都是一边吃， 一边看书。 但是现在， 我采用了禁网的方式， 把自己和网络隔离开来， 其实也并没有完全隔离开来， 毕竟还有手机这东西， 说起来我好像也找到了一点原因了， 那就是还有手机。 我现在是没有电脑上网了， 但是手机却还是能够上网， 所以觉得累的时候， 就会打开手机逛逛贴吧， 想象中只是逛逛而已， 结果这一玩儿， 就浪费了大把的时间， 就好像周六周日的午休一样， 不午休还好， 只要一午休， 一般就会从1.30睡到4.00， 我以后大概都不敢再在周末的时候躺在床上午休了吧。 浪费的大把的时间是真的一去不复返了。 </p>
<p>之前的时候， 我跟朋友说来到北京之后， 胖了不止一圈了。 朋友说她在家的时候每天早上都还跑步呢， 叫我也多锻炼身体， 当时我说我把时间都用来学习了， 腾不出时间来锻炼身体， 等以后有空了再慢慢锻炼吧。 现在想起来也真是讽刺， 每天浪费了大把大把的时间， 却说自己把所有时间都用来学习了。</p>
<p>提升自我控制能力应该是一件值得我花一辈子的时间去做的事情吧。 我相信做好这件事情给我带来的好处能和每天吃上土豆给我精神上带来的好处相媲美。当然，前提是我真正地把它给做好了。 如果满分是100分的话， 我会毫不留情地给现在的自己打上0分， 弱爆了的自我控制能力。 我是一个自负的人， 任何的事情除了我主观意识上接受了之外， 不会有任何人能够影响我。我认为不对的东西， 即使有人在我耳边吹了一万遍它是正确的 ， 我依然会以为它不对。 我也很讨厌那种洗脑式， 自以为是的真理式的吹风行为。 所以对于那种所谓提升自我控制能力的几个技巧啊， 提升自我控制能力的啥啥书啥的东西， 我是一直持着不屑的态度的， 从来不喜欢看这种类型的书。同理， 对于时间管理方面的培训我也是一万个不愿意， 时间管理嘛， 有了日事清就够了， 还培训个啥， 这破培训才是真的浪费时间。 但是没办法， 领导喜欢玩这一套你就得由着他。  </p>
<p>突然发现明明自己写的是关于最近的一些事， 但是话题却始终是围绕着时间两个字在转。说起来， 抛开业余时间不谈，工作的时候时间排得倒是挺合理的（在有活儿干的情况下）， 毕竟咱做的软件就是时间管理方面的。当然， 现在做项目的时候， 项目管理流程走得也是挺不错的， 至少不会有各种各样的大会小会充斥着你每一天的时间， 最多也就每个周例行的半个小时的工作安排会议。 所以自己真正应该改变的便是业余时间的控制吧。  </p>
<p>感觉自己真的是太久没动笔了， 一动笔的时候通篇都是废话， 熬到现在也熬不出几个字儿了。 哎， 曾经的才子如今已是江郎才尽<br>:悲伤。 那就给刚入门的前端小伙伴们一点忠告吧。 在基础没打扎实前， 千万不要折腾除了jQuery之外的其他框架。 讲真， 这段时间里最好的做法就是打好基础打好基础打好基础。 只有JS基础打好了， 后面学框架这些东西的时候才会更快。 血淋淋的教训啊， 当初年轻不懂事， 学了点JS就去折腾框架， 结果浪费了我不少时间不说， 最为悲惨的是到最后真的只是学到了个鸟 →＿← 。 </p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>纯CSS实现单击锚点平滑切换的效果</title>
    <url>/2016/05/10/%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%87%BB%E9%94%9A%E7%82%B9%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%9A%84%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>有时想实现一个功能，比如想让页面不出现滚动条，但是却能装下更多的东西，这个时候我们会对某个容器设 置<code>overflow: hidden</code>，然后通过锚点来实现单击切换页面（其实只是控制显示的内容）的效果。但是通过锚点来跳到指定内容的不足之处在于，没有什么过渡效果，很突兀的就跳到了目标点。当然，也可以通过JS或者jQuery来实现自己想要的动态切换效果，这一类的文章一搜一大堆，这里就不赘述了。</p>
<a id="more"></a>
<p>但是在一些个人主页中，比如github的个人主页（只是主页而已，也就是username.github.io）上会禁止JS脚本的运行，这个时候如果还是想通过单击锚点平滑切换的功能的话，应该怎么办呢？</p>
<p>原谅我是一个前端初学者，傻想了很久也想不到什么办法，然后就百度谷歌了。</p>
<p>后来找到了一些方法，比如用radio配合他的check属性来实现，<span class="exturl" data-url="aHR0cDovL3R5bXBhbnVzLm5ldC9jb2Ryb3BzLzIwMTIvMDYvMTIvY3NzLW9ubHktcmVzcG9uc2l2ZS1sYXlvdXQtd2l0aC1zbW9vdGgtdHJhbnNpdGlvbnMv">文章在这里<i class="fa fa-external-link-alt"></i></span>,关于这个方法，<span class="exturl" data-url="aHR0cDovL3d3dy5pbW9vYy5jb20vdmlldy8yNTI=">慕课<i class="fa fa-external-link-alt"></i></span>上也有专门的教程，大家也可以去看看。</p>
<p>但是可不可以不插入radio就实现对应的效果呢？ 答案是有的。</p>
<p>那就是利用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTLyUzQXRhcmdldA==">:target<i class="fa fa-external-link-alt"></i></span>伪类，这个选择器可以选择当前活动的锚点,那么利用这个属性我们就可以实现自己想要的效果了。</p>
<p>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#tag1"</span>&gt;</span>Tag1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#tag2"</span>&gt;</span>Tag2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#tag3"</span>&gt;</span>Tag3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tag1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tag2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tag3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#tag1</span>, <span class="selector-id">#tag2</span>, <span class="selector-id">#tag3</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all ease-out .<span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">0</span></span><br><span class="line">  left:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#tag1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f66</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#tag2</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#tag3</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#container</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:target</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1000</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9qc2ZpZGRsZS5uZXQvMjQza2pMNjAvMi8=">查看DEMO<i class="fa fa-external-link-alt"></i></span></p>
<p>上面的例子是通过绝对定位配合z-index和透明度来实现的动态效果。先将所有的元素的opacity设为0，然后为了默认显示出来第一个元素，所以第一个元素的opacity为1，z-index为1。然后单击就可以实现动态切换了。</p>
<p>其实我最先尝试的是通过给<code>#container</code>设置<code>overflow: hidden;</code>, 为它的子元素设置<code>height:100%;</code>，然后给target设置margin-top为负的百分比值来实现相应效果的，毕竟比较喜欢这种从下往上冒或者从上往下掉的感觉嘛。。。但是在实现过程中遇到了一点小问题，那就是当Tag2和Tag3相互切换的时候，居然只会移动到一半就不再动了，如果把<code>overflow: hidden</code>去掉，显示的就是自己期望的效果。<span class="exturl" data-url="aHR0cHM6Ly9qc2ZpZGRsZS5uZXQvYmV6YnUzajIv">一个有问题的DEMO<i class="fa fa-external-link-alt"></i></span> </p>
<p>后来自己想到了解决的办法，那就是给container包裹一个div，然后把<code>overflow: hidden</code>设置在这个元素身上，再把container的overflow去掉，设置高度为它子元素的高度，这样就能显示正常了。 <span class="exturl" data-url="aHR0cHM6Ly9qc2ZpZGRsZS5uZXQvZGMzc3ZkdmYvNC8=">DEMO在这里<i class="fa fa-external-link-alt"></i></span>.</p>
<p>虽然找到了解决办法，但是对于<span class="exturl" data-url="aHR0cHM6Ly9qc2ZpZGRsZS5uZXQvYmV6YnUzajIv">问题DEMO<i class="fa fa-external-link-alt"></i></span> 里的这种怪异行为真的不理解，如果各位谁知道的话，还请告知，谢谢。</p>
<p>参见：<br><span class="exturl" data-url="aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNzYzMTQxNy9jc3MtcHVyZS1jc3Mtc2Nyb2xsLWFuaW1hdGlvbg==">stackoverflow - 纯CSS滚动效果<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊 Proxy</title>
    <url>/2019/12/27/%E8%81%8A%E4%B8%80%E8%81%8A%20Proxy/</url>
    <content><![CDATA[<blockquote>
<p>给我一个万能的对象吧，她要能唱歌会跳舞，卖萌一级棒，会写代码还没有bug<br>咦，走错片儿场了，重新来<br>给我一个万能的对象吧，它能无限层次地随便访问属性，能当函数调用，还永远不会报错~</p>
</blockquote>
<p>本周做了一个需求，扫描负责仓库下所用到的接口。通常来讲，这样的需求通过简单的查找就能完成，然而实际操作中存在以下问题：</p>
<a id="more"></a> 

<ul>
<li>请求方式不一致 —— 通常来讲，大多数url的前缀都是一致的，因此为了便于后面的修改，我们可能会对这些一致的前缀进行抽象提取处理，而具体的抽象方式又不一致，比如以下几种：<ul>
<li>使用字符串拼接</li>
<li>使用函数封装返回一个字符串</li>
</ul>
</li>
</ul>
<p>因此，直接通过关键字过滤的方法来扫描接口，基本上是不可行的。</p>
<p>既然每个文件最后都会export 一个方法，于是便想到了直接获取指定项目下的所有文件，通过动态require的方式，获取他们的exports，通过参数注入的方法，注入自定义的 request，从而进行扫描记录。</p>
<p>然而这样又会有一个问题，我们的项目中，对于一个请求，通常都会直接从state中获取相应的请求参数，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getUser = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function">(<span class="params">dispatch, getState, &#123; request &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> &#123; userId &#125; = getState().location.query;</span><br><span class="line">  <span class="keyword">return</span> request(uri, &#123; <span class="attr">query</span>: &#123; userId &#125; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个实例方法里，函数体内部会从 state 中获取location.query.userId，因此，getState函数就需要我们返回一个对象，该对象需要能够确保这一次state的访问能够成功 —— 如果报错的话，后面的request就不能执行，也就没法记录相应的url了。</p>
<p>针对这样一个单独的方法，我们可以返回相应的符合状态的对象，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">	location: &#123;</span><br><span class="line">  	query: &#123;</span><br><span class="line">    	userId: <span class="number">111</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然而实际上，我们一个文件中可能是10+甚至更多的 export，而这样的文件也可能又数十上百个，如果再单独针对每一种场景都去这样处理的话，那通过工具扫描代码以便于节省人力的意义就没有了 —— 毕竟有这精力还不如直接一个接口一个接口的进行统计。</p>
<p>那么我们需要的是一个什么样的东西呢？</p>
<p>由于最终我们要解决的问题是需要确保函数体内的属性访问、方法调用都不会报错，从而使得函数能够执行到最后 —— 调用request方法，因此实际上我们需要的就是这样一个对象 —— 我可以任意地访问它的属性，以及访问它返回的属性的属性却不会报错，甚至能够安全地不受限制地进行访问。</p>
<p>一般来讲，针对一个对象而言，我们对它进行访问的时候，直接访问它的属性 —— 当然，这是废话，可是 ES5 告诉我们可以通过 Object.defineProperty 对对象的属性访问进行劫持，返回我们想让它返回的东西。而一旦聊到劫持，大概率我们会想到 Vue，以及 Vue 3.0 使用 Proxy 进行数据劫持。因此，答案也就呼之欲出了，使用 Proxy 应该是可行的。</p>
<p>考虑到我们的返回应该是可无限链式调用的对象，那么很明显，除了对于一开始的对象我们需要劫持，对于后续我们返回的对象，也是需要劫持的，因此代码可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = <span class="function">(<span class="params">config</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">	<span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">  	<span class="keyword">return</span> gen(config)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(gen().name.age.gender.hobby)</span><br></pre></td></tr></table></figure>
<p>执行代码一看，果然可行耶，也不会报错<br><img align=left height=140 width=249 data-src="https://cdn.nlark.com/yuque/0/2019/png/434020/1577461305404-c61c44bd-eaae-4d1c-88dc-5a9f4dfbe99e.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /></p>
<p>直到遇上了这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = gen()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(state.userId)</span><br></pre></td></tr></table></figure>

<p>然后报了这个错：<br><img align=left height=89 width=464 data-src="https://cdn.nlark.com/yuque/0/2019/png/434020/1577461389240-4a835bc3-6818-450a-a762-bcdc2bc24edb.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /></p>
<p>错误信息告诉我们 object is not a function ，可是找遍了整段代码，没有见到 object 啊，那是什么问题呢？</p>
<p>我们看一下当调用Number方法的时候会发生什么(参见<span class="exturl" data-url="aHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzkuMC9pbmRleC5odG1sI3NlYy1udW1iZXItY29uc3RydWN0b3ItbnVtYmVyLXZhbHVl">ECMA-262<i class="fa fa-external-link-alt"></i></span>)<br><img align=left height=269 width=911 data-src="https://cdn.nlark.com/yuque/0/2019/png/434020/1577462030678-0bcae900-2f5b-47df-95cd-a3554ac8c42c.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /><br><img align=left height=583 width=830 data-src="https://cdn.nlark.com/yuque/0/2019/png/434020/1577462057147-e08b4edb-173c-45af-9571-b38017c02e3a.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /><br><img align=left height=558 width=937 data-src="https://cdn.nlark.com/yuque/0/2019/png/434020/1577462251462-c544cf2c-70fd-4394-9c58-8cfac22c5f01.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /><br>规范告诉我们，当我们调用Number()方法，并且传递了一个对象的时候，会执行以下步骤：</p>
<ul>
<li>通过toPrimitive(argument, hintNumber)方法，获取到 primValue<ul>
<li>这里是对象，所以最后会通过输入参数的toPrimitive方法来获取到一个返回值</li>
</ul>
</li>
<li>返回toNumber(primValue)</li>
</ul>
<p>而 toPrimitive 方法是一个内部方法，它使用了Symbol来定义了一个单独的变量作为方法名，通常情况下我们是无法获取到它的。</p>
<p>因此，我们需要hack一下，以便于获取到这个内部值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PrimitiveSymbol = getPrimitiveValue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPrimitiveValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> toPrimitiveValue</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Number</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">        <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'symbol'</span>) &#123;</span><br><span class="line">            PrimitiveSymbol = key</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> PrimitiveSymbol</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来再对之前的代码进行一番改造：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> PrimitiveSymbol = getPrimitiveValue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ret = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === toPrimitiveSymbol) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'111'</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = gen()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(state.name.age.feature.log.info.error.cheese)</span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(state)</span><br><span class="line"><span class="built_in">Number</span>(state)</span><br><span class="line">state / <span class="number">2</span></span><br><span class="line">state + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">/<span class="number">123</span>/.exec(state)</span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(state, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">parseFloat</span>(state)</span><br><span class="line"></span><br><span class="line">state &gt;&gt;&gt; <span class="number">12</span></span><br><span class="line">state | <span class="number">123</span></span><br><span class="line">state &amp; <span class="number">999</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPrimitiveValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> PrimitiveSymbol</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Number</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">        <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'symbol'</span>) &#123;</span><br><span class="line">            PrimitiveSymbol = key</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> PrimitiveSymbol</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再执行一次，发现无错通过~</p>
<p>直到遇见了下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createUser =&gt; <span class="function"><span class="params">()</span> =&gt;</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; getUser &#125; = getState()</span><br><span class="line">  <span class="keyword">const</span> user = getUser()</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是又悲剧的报错了</p>
<img align=left height=71 width=486 data-src="https://cdn.nlark.com/yuque/0/2019/png/434020/1577463103252-8b7385e5-eb75-4982-8390-a7c678441f05.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" />

<p>我们万能的对象随便访问属性是可以的，然而当我把它当成函数调用的时候，就又报错啦<br>state 不是用来存放数据的吗， 为什么会有人在里面放函数？鬼知道为什么 - -<br>我们控制不了函数内部的调用，那就只好自己去适配了，那该怎么配呢 o(╯□╰)o</p>
<p>似乎一开始代理的就不应该只是一个单纯的对象，它应该是一个函数对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ret = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === PrimitiveSymbol) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'111'</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们的目的就达到了， 应该可以随便扫代码了。。。 吧。。</p>
<p>后记：<br>-今天每日阅读的两篇文章大概率是完不成了o(╯□╰)o</p>
<p>-其实Proxy的应用场景还是挺多的，这不 Vue 3.0 也快出了吗，用的 Proxy，我想知道应用到底创建了多少个 Proxy 应该怎么办呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OriginalProxy = <span class="built_in">Proxy</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instances = <span class="number">0</span></span><br><span class="line"><span class="built_in">window</span>.Proxy = <span class="keyword">new</span> OriginalProxy(<span class="built_in">Proxy</span>, &#123;</span><br><span class="line">  construct(...args) &#123;</span><br><span class="line">    instances++</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instances)</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>每天学习一丢丢~</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊 Same-Site</title>
    <url>/2020/04/01/%E8%81%8A%E4%B8%80%E8%81%8A%20Same-Site/</url>
    <content><![CDATA[<p><a name="xYJLg"></a></p>
<h2 id="什么是SameSite"><a href="#什么是SameSite" class="headerlink" title="什么是SameSite?"></a>什么是SameSite?</h2><blockquote>
<p>   A request is “same-site” if its target’s URI’s origin’s registrable</p>
</blockquote>
<a id="more"></a> 
<blockquote>
<p>   domain is an exact match for the request’s client’s “site for<br>   cookies”, or if the request has no client.  The request is otherwise</p>
</blockquote>
<blockquote>
<p>   “cross-site”.</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>   For a given request (“request”), the following algorithm returns</p>
</blockquote>
<blockquote>
<p>   “same-site” or “cross-site”:</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<ol>
<li>If “request”‘s client is “null”, return “same-site”.</li>
</ol>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<pre><code>Note that this is the case for navigation triggered by the user</code></pre></blockquote>
<blockquote>
<pre><code>directly (e.g. by typing directly into a user agent&apos;s address</code></pre></blockquote>
<blockquote>
<pre><code>bar).</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<ol start="2">
<li>Let “site” be “request”‘s client’s “site for cookies” (as defined</li>
</ol>
</blockquote>
<blockquote>
<pre><code>in the following sections).</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<ol start="3">
<li>Let “target” be the registrable domain of “request”‘s current</li>
</ol>
</blockquote>
<blockquote>
<pre><code>url.</code></pre><ol start="4">
<li>If “site” is an exact match for “target”, return “same-site”.</li>
</ol>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<ol start="5">
<li>Return “cross-site”.</li>
</ol>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>   The request’s client’s “site for cookies” is calculated depending</p>
</blockquote>
<blockquote>
<p>   upon its client’s type, as described in the following subsections:</p>
</blockquote>
<p>如上文所示，只有当请求的站点的 origin 和 当前浏览器站点地址origin 完全匹配时，才叫做 same-site，具体采用以下策略：</p>
<ul>
<li>request client 为null（如用户直接在浏览器中输入url），则为same-site</li>
</ul>
<p><a name="caR0y"></a></p>
<h3 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h3><p><a name="9HzOh"></a></p>
<h4 id="文档请求（Document-based-requests）"><a href="#文档请求（Document-based-requests）" class="headerlink" title="文档请求（Document-based requests）"></a>文档请求（Document-based requests）</h4><p>只有用户自己输入的URL才是暴露给用户的唯一安全的上下文。该URL对应的domain也应该是用户信任的站点。我们将其标记为 top-level-site。</p>
<p>因此，对于这样的请求，其 “site for cookies” 可以认为就是 top-level-site。</p>
<p>对于top-level-site中嵌套的上下文，只有当每一个文档及其祖先文档的origin与当前top-level-site相同时，site-for-cookies才等于top-level-site，否则则为空字符串。</p>
<p><a name="HJ9BT"></a></p>
<h4 id="Worker-请求"><a href="#Worker-请求" class="headerlink" title="Worker 请求"></a>Worker 请求</h4><p><a name="P3k1S"></a></p>
<h5 id="专用以及共享的worker"><a href="#专用以及共享的worker" class="headerlink" title="专用以及共享的worker"></a>专用以及共享的worker</h5><p>专用的worker都绑定了唯一的文档，因此这种类型的worker发出的请求（importScripts、XHR、fetch等）其site-for-cookies 就是绑定文档的site。</p>
<p>共享的worker可能一次性绑定了多个文档，这些文档的 “site-for-cookies”值可能都不一致，在这种情况下，最后会返回一个空字符串，当所有值都相同的时候，则返回相同的这个值。</p>
<p>简而言之，只要有一个文档的 document-site 和 worker 注册的site 不一致，那么就返回空字符串。</p>
<p><a name="rarjN"></a></p>
<h5 id="ServiceWorker"><a href="#ServiceWorker" class="headerlink" title="ServiceWorker"></a>ServiceWorker</h5><p>返回注册 worker 的 origin 的host</p>
<p>从 Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪。</p>
<p><code>**Set-Cookie: CookieName=CookieValue; SameSite=Strict;**</code> </p>
<p>该属性有三个值：Strict、Lax、None</p>
<p><a name="S1loy"></a></p>
<h2 id="值"><a href="#值" class="headerlink" title="值"></a>值</h2><p><a name="zlrzJ"></a></p>
<h3 id="Strict"><a href="#Strict" class="headerlink" title="Strict"></a>Strict</h3><p>只有在第一方（宿主）上下文才会发送Cookie。第三方站点初始化的请求都不会携带Cookie。包含从宿主环境打开的链接 —— 如在a.b.com打开了，a.c.com的页面，那么在刚刚打开的这个页面中， SameSite 为 Strict 的 Cookie也不会被发送， 因为它是由B打开的。只有用户主动输入a.c.com的链接的情况下，SameSite 为 Strict 的Cookie才会被发送。</p>
<blockquote>
<p>不确定是否是根据document.referrer判断的，因为该属性为只读属性</p>
</blockquote>
<p><a name="AjbJH"></a></p>
<h3 id="Lax"><a href="#Lax" class="headerlink" title="Lax"></a>Lax</h3><p>TOP-LEVEL NAVIGATIONS 下的请求允许发送Cookie；以及被第三方站点初始化的get请求（导航到目标网址的 Get 请求）也允许发送 Cookie；现代浏览器默认为它。<br><img align=left height=673 width=1920 data-src="https://cdn.nlark.com/yuque/0/2020/png/434020/1585746235216-bb779b81-b398-4299-a233-f0bf550bf837.png" style="margin: 0 10px 0 0;" referrerpolicy="no-referrer" /></p>
<p><a name="TNDSs"></a></p>
<h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><p>在所有的上下文当中 Cookie 都允许被发送，跨域也允许。<br>None 值在以前作为浏览器的默认值，但是在最近浏览器默认值变为了Lax，以防范CSRF攻击。<br>最新的浏览器要求在指定SameSite为None的同时，要求指定Secure属性；</p>
<p><a name="ljITx"></a></p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul>
<li>Node 要发送多个相同名称的Header（如Set Cookie）的haul，需要使用 <code>res.setHeader(headerName, valueArray)</code> 的方式，并且如果后续调用writeHead的话，不能重复添加相应的Header</li>
</ul>
<p><a name="xsiL8"></a></p>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> content = <span class="built_in">require</span>(<span class="string">'fs'</span>).readFileSync(<span class="string">'./index.html'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">const</span> body = <span class="string">``</span></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers)</span><br><span class="line">  res.setHeader(<span class="string">'Set-Cookie'</span>, [<span class="string">'lax=lax; SameSite=Lax'</span>, <span class="string">'strict=strict; SameSite=Strict'</span>, <span class="string">'uid5555=100;domain=.com;'</span>])</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">    <span class="comment">// 请求携带凭据的时候，这里不能为*</span></span><br><span class="line">    <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'http://a.b.com'</span>,</span><br><span class="line">    <span class="comment">// 当没有该请求头，但是实际请求发生的时候携带了凭证的话，也会报错</span></span><br><span class="line">    <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'Access-Control-Allow-Methods'</span>: <span class="string">'GET,POST'</span>,</span><br><span class="line">    <span class="comment">// allow-headers 非必须；传递了也不会有影响；</span></span><br><span class="line">    <span class="comment">// 'Access-Control-Allow-Headers': 'content-type,x-requested-with', /</span></span><br><span class="line">    <span class="comment">// 'Set-Cookie': ,</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.end(<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">status</span>: <span class="string">'ok'</span> &#125;))</span><br><span class="line">&#125;).listen(<span class="number">3002</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> content = <span class="built_in">require</span>(<span class="string">'fs'</span>).readFileSync(<span class="string">'./index.html'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">const</span> body = <span class="string">``</span></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'here......'</span>)</span><br><span class="line">  <span class="comment">// res.statusCode = 301</span></span><br><span class="line">  <span class="comment">// res.setHeader('Location', 'http://localhost')</span></span><br><span class="line">  res.statusCode = <span class="number">200</span>;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'fs'</span>).createReadStream(<span class="string">'./index.html'</span>).pipe(res)</span><br><span class="line">  <span class="comment">// res.end(content)</span></span><br><span class="line">&#125;).listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试跨域233<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span> 点我跨域<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"post"</span>&gt;</span> 点我跨域POST<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://a.meituan.com/c/age"</span>&gt;</span>这是一个标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>).onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">    fetch(<span class="string">'http://a.meituan.com/getUser'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">      credentials: <span class="string">'include'</span>,</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">'post'</span>).onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">    fetch(<span class="string">'http://a.meituan.com/getUser'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">      method: <span class="string">'post'</span>,</span></span><br><span class="line"><span class="actionscript">      credentials: <span class="string">'include'</span>,</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>参考文档：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1NldC1Db29raWUvU2FtZVNpdGU=">SameSite<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <tags>
        <tag>每天学习一丢丢~</tag>
      </tags>
  </entry>
  <entry>
    <title>设置text-overflow為ellipsis后引起的文本对齐问题</title>
    <url>/2016/05/10/%E8%AE%BE%E7%BD%AE-text-overflow-ellipsis-%E5%90%8E%E5%BC%95%E8%B5%B7%E7%9A%84%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近在做网页的时候用到了文本溢出隐藏的功能，但是出现了一些小问题，下面先放上示例代码吧。</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Hello Hello Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>xhaha<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">40%</span>;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="comment">/* overflow: hidden; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9qc2ZpZGRsZS5uZXQvcHNrcGNmYzgvMS8=">查看DEMO<i class="fa fa-external-link-alt"></i></span></p>
<p>按以上代码最后得到的显示效果是，<code>span.left</code>和<code>span.right</code>没有对齐。右边的会沉下去点，这个在demo里面可以看到。</p>
<p>然后我就想这是什么原因造成的，在调试器里勾选掉<code>.left</code>的<code>overflow: hidden</code>后，就显示正常了（当然，省略号儿也没了），然后我就捉摸着这是不是BFC的问题，因为平时自己清除浮动什么的，都喜欢用<code>overflow:hidden</code>来触发BFC，以便包裹元素的来着。当然了，给.right设置<code>overflow: hidden</code>或者<code>float: right</code>之后，也确实会显示正常（<code>float: right</code>会让文字右浮动，不过对齐的效果确实是达到了)，之后我就在BFC的问题上纠结了好久，因为<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvQ1NTL0Jsb2NrX2Zvcm1hdHRpbmdfY29udGV4dA==">MDN<i class="fa fa-external-link-alt"></i></span>上说了，<code>inline-block</code>元素本身就是会触发BFC的，那么前面所说的和BFC有关，就不那么准确了。</p>
<p>后来在stackoverflow上得到了答案，对<code>span</code>加上一个<code>vertical-align: top</code>然后就会对齐了。</p>
<p>至于原因，是因为<code>inline-block</code>元素默认的对齐方式是基线对齐，那么基线是什么呢？　如果一个<code>inline-block</code>盒子是空的，或者说他的<code>overflow</code>属性不为<code>visible</code>, 那么他的基线就是其下边距边缘，否则的话，就是其内部最后一个内联元素的基线（文字就是内联元素咯。。）</p>
<p>如下所示：</p>
<p><img data-src="http://images2015.cnblogs.com/blog/852232/201601/852232-20160106180012621-339338620.png" alt=""></p>
<blockquote>
<p>The baseline of an ‘inline-block’ is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its ‘overflow’ property has a computed value other than ‘visible’, in which case the baseline is the bottom margin edge.</p>
</blockquote>
<p>那么，span.left的基线就是那个背景色的最下边，而右边span.right的基线，就是字符x的底部，基线对齐的意思，就是这两条线是在同一水平线上的，所以，右边的元素为了对齐，就要往下沉咯。现在我们目测的话，也是这两条线貌似也确实是在一条水平线上的。</p>
<p>所以，设置了<code>vertical-align: top</code>之后，改变了其默认对齐方式，所以就对齐咯。</p>
<p>然后使用右浮动之后，因为浮动会使盒子的<code>display</code>属性变为<code>block</code>，所以就不是<code>inline-block</code>元素，自然就不会受到前面的规则的影响了。</p>
<p>之后是使用<code>overflow: hidden</code>，这个属性使得inline-block元素的基线发生了改变，变得和左边元素一样，所以也能对齐。</p>
<p>最后来个小总结吧： 好的文章一定要多读几遍，每一遍都会有所收获。</p>
<p>参见：<br><span class="exturl" data-url="aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjk1MDQ3OS93aHktZG9lcy1pbmxpbmUtYmxvY2stZWxlbWVudC1oYXZpbmctY29udGVudC1ub3QtdmVydGljYWxseS1hbGlnbmVk">stackoverflow- inline-block元素垂直对齐问题<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy56aGFuZ3hpbnh1LmNvbS93b3JkcHJlc3MvMjAxNS8wOC9jc3MtZGVlcC11bmRlcnN0YW5kLXZlcnRpY2FsLWFsaWduLWFuZC1saW5lLWhlaWdodC8=">张鑫旭-CSS深入理解vertical-align和line-height的基友关系<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次事件捕获的妙用</title>
    <url>/2016/06/03/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    <content><![CDATA[<p><code>JavaScript</code>事件流有事件捕获， 处于目标及事件冒泡三个阶段。 在使用<code>addEventListener</code>注册事件的时候, 其第三个参数也可以选择将事件注册在哪个阶段。 平时我们事件大多都是注册在冒泡阶段的， 所以第三个参数一般都是传递的<code>false</code>， 由于很少使用到事件捕获， 所以久而久之也就忘了还有这一茬了。但是其实在某些特定的场景下， 事件捕获还是挺有用的。  </p>
<a id="more"></a>


<p>在之前的业务中， 碰到了一个关于弹窗的关闭顺序的问题。 </p>
<p>由于在系统中使用了<code>popover</code>， <code>inside-modal</code>, <code>modal</code>, <code>dropdown</code>等弹窗， 并且存在级联<code>popover</code>， 然后为了方便管理<code>esc</code>关闭弹窗的功能， 同事做了一个<code>esc</code>事件队列管理器， 其原理就是对<code>document</code>进行代理， 在按下<code>esc</code>的时候， 优先触发最后绑定的事件。</p>
<p>本来这个功能用的好好的， 但是后来发现了一个问题。我们系统中所使用的第三方的文件预览插件<code>Magnific-Popup</code>所附带的弹窗也是在<code>document</code>上绑定了<code>esc</code>退出功能的， 但是由于该插件并没有具体地集成到系统中， 所以他绑定的事件是没有加入到事件队列管理器里面的。这样造成的问题是， 在文件（<code>inside-modal</code>弹窗）中点击文件预览的时候， 打开了弹窗， 当按下<code>esc</code>的时候， 本来期望的只是关闭预览弹窗， 但是由于队列管理器对事件触发顺序进行了处理， 最后结果是先关闭了文件（<code>inside-modal</code>）弹窗， 然后才会关闭预览弹窗。毫无疑问， 这个问题的影响是比较严重的。</p>
<p>文件弹窗 ：<br><img data-src="http://o869zxhjd.bkt.clouddn.com/inside-modal.png" alt="inside-modal"></p>
<p>文件预览弹窗：<br><img data-src="http://o869zxhjd.bkt.clouddn.com/%E6%96%87%E4%BB%B6%E9%A2%84%E8%A7%88.png" alt="文件预览弹窗"></p>
<p>在这种情况下，直接阻止事件冒泡是没有效果的， 因为事件冒泡只是阻止事件的传递而已， 并且由于两者事件都是注册在<code>document</code>上的， 而这里涉及到的是事件触发顺序的问题（管理器里的事件优先触发）。 </p>
<p>所以， 这个时候就可以用到事件捕获了。 我们知道， 事件捕获是从最外层向最里层传递的， 也就是从<code>window</code>上面开始传递， 所以这里可以对<code>window</code>绑定文件预览弹窗的<code>esc</code>事件： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'keydown'</span>, _closeDialog, <span class="literal">true</span>); <span class="comment">// 注意第三个参数是true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_closeDialog</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(e &amp;&amp; e.keyCode === <span class="number">27</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'keydown'</span>, _closeDialog, <span class="literal">true</span>);</span><br><span class="line">    mfp.close();</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!e) &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'keydown'</span>, _closeDialog, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在其事件处理程序中， 调用事件对象的<code>stopPropagation()</code>来阻止事件向下一层元素传递， 这样一来<code>document</code>上就不能接收到该事件了， 从而使得在文件预览弹窗里按下<code>esc</code>的时候， 事件队列处理器不能够接收到相应事件，保证了预期效果。</p>
<p>最后总结一下， 这里总共做了两个操作： </p>
<ul>
<li>将预览弹窗的<code>keydown</code>事件注册到<code>window</code>上面</li>
<li>将该事件注册在事件捕获阶段</li>
</ul>
<p>需要注意的是， 移除事件所用的参数只有和绑定事件的参数一致的时候才能够准确地移除事件哈。</p>
<p>当然，也许针对这个问题还会有更好的解决方案， 只是当时为了保证开发效率， 就直接采用能够想到的方案了。 </p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>近期学习计划及总结</title>
    <url>/2016/05/17/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%E5%8F%8A%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>最近大概又是进入了一个迷茫期。   </p>
<p>虽然自己也知道贪多嚼不烂的道理， 但是却总是觉得应该优先提升自己知识上的广度， 等对前后端服务器有了一个宏观上的认识了， 再去提升知识的深度。 所以这段时间把<code>CSS</code>, <code>JS</code>一类的东西给放下了， 开始学习<code>php</code>, <code>mysql</code>， 原本的打算是先学着这个， 弄熟悉了打好基础了， 再去学其他的。 结果呢， 学了一些基础的东西后， 又想要开始学算法， 然后买了本算法书， 结果算法书的里面用的语言是<code>java</code>, 然后我又继续开始学<code>JAVA</code>。 虽然说里面的有些东西用JS也是可以实现的， 但是总觉得照着书本上先尝试一遍才能更好的理解。<strong>5.24注： 现在感觉还是用JS先实现一遍比较好→＿←→＿←→＿←</strong> 然而我现在算法还没学完， 就想要开始学<code>linux</code>和<code>nginx</code>了。  </p>
<a id="more"></a>

<p>说起来， 刚刚步入前端大概有3个月的时候，学了会儿<code>nodejs</code>， 也顺带学了<code>mongodb</code>， 然而那时候学的东西现在差不多都忘完了。 还有其他的框架之类的东西也是， 如果没有办法在生产环境中应用的话， 总是很快就会忘掉。 所以从那之后我就没有在框架一类的东西上花费太多功夫了。 </p>
<p>哎呀写不下去了。 →＿←→＿←→＿←→＿←</p>
<p>总之现在的设想是， 先把算法学习了， 在把算法书啃完之后， <code>JAVA</code>基础也能了解个大概， 对算法也可能会有一个比较清晰的认识。 然后便是根据慕课网上的对应语言的案例来尝试自己写一套代码以便提升熟练度和查漏补缺， 方便找到薄弱点。 下一步就应该是学习<code>linux</code>以及<code>nginx</code>的配置了，之后便是深入学习<code>nodejs</code>以及<code>js</code>, <code>css</code>吧， 自己现在写<code>css</code>的时候真的是有种凑效果的嫌疑， 要是什么时候能够达到写一遍代码就能得到想要效果的境界就好了。 </p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
